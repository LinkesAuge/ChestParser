---
description: Bug Fixing Log
globs: *.py
alwaysApply: false
---
# Bug Fixing Log

## Fixed Issues

### 2024-03-12: Matplotlib and PySide6 Compatibility

**Issue:** 
The application was failing to start with the following error:
```
ImportError: Failed to import any of the following Qt binding modules: PyQt5, PySide2
```

**Root Cause:**
Matplotlib was attempting to use Qt5 backends (PyQt5 or PySide2) but the application was using PySide6.

**Solution:**
1. Changed the matplotlib import from `backend_qt5agg` to `backend_qtagg`
2. Added explicit backend configuration:
   ```python
   import matplotlib
   matplotlib.use('QtAgg')  # Use the generic Qt backend that works with PySide6
   from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg as FigureCanvas
   ```

**Verification:**
Successfully ran the application without import errors.

### 2024-03-12: CSV Encoding Issue

**Issue:**
When importing a CSV file, the following error occurred:
```
Failed to load CSV file: Error loading CSV file: 'utf-8'codec can't decode byte 0xfc in position 395: invalid start byte
```

**Root Cause:**
The application was trying to read the CSV file using UTF-8 encoding, but the file contained characters (like 'Ã¼', byte 0xfc) that were encoded using a different encoding format, likely Windows-1252 or Latin-1.

**Solution:**
Modified the `DataProcessor.load_csv()` method to try multiple encodings:
```python
@staticmethod
def load_csv(filepath):
    """
    Load CSV data from file and return as pandas DataFrame.
    
    Attempts different encodings if the default UTF-8 fails.
    """
    encodings_to_try = ['utf-8', 'latin1', 'iso-8859-1', 'cp1252', 'windows-1252']
    
    for encoding in encodings_to_try:
        try:
            df = pd.read_csv(filepath, encoding=encoding)
            # Remove CLAN column as per requirements
            if 'CLAN' in df.columns:
                df = df.drop(columns=['CLAN'])
            return df
        except UnicodeDecodeError:
            # Try the next encoding
            continue
        except Exception as e:
            # For other exceptions, raise immediately
            raise ValueError(f"Error loading CSV file: {str(e)}")
            
    # If we've tried all encodings and none worked
    raise ValueError("Could not decode the CSV file with any supported encoding. Please check the file format.")
```

**Verification:**
This change should allow the application to properly import CSV files with various encodings commonly used for European languages.

### 2024-03-12: Pandas DataFrame Boolean Evaluation

**Issue:**
After fixing the CSV encoding, the application showed this error when trying to load a file:
```
ValueError: The truth value of a DataFrame is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().
```

**Root Cause:**
In the `update_filter_options` and `filter_raw_data` methods, the code was directly checking if the DataFrame was falsy with `if not self.raw_data`, but pandas DataFrames can't be evaluated as booleans this way.

**Solution:**
Modified both methods to properly check for None or empty DataFrames:
```python
def update_filter_options(self):
    """Update filter options based on selected column"""
    if self.raw_data is None or self.raw_data.empty or self.column_selector.currentText() == "":
        return
    
    # Rest of the method...

def filter_raw_data(self):
    """Filter raw data based on selected criteria"""
    if self.raw_data is None or self.raw_data.empty or self.column_selector.currentText() == "":
        return
    
    # Rest of the method...
```

**Verification:**
This fix prevents pandas from trying to evaluate the DataFrame as a boolean value.

### 2024-03-12: QSortFilterProxyModel API Update

**Issue:**
The application threw an error related to filter methods:
```
self.raw_data_proxy_model.setFilterRegExp("")
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
ou mean: 'setFilterRole'?
```

**Root Cause:**
The application was using `setFilterRegExp()` which is no longer available or has been deprecated in the version of PySide6 being used (6.8.2.1).

**Solution:**
Updated the filtering code to use the current API:
```python
# Changed from
self.raw_data_proxy_model.setFilterRegExp("")
# To
self.raw_data_proxy_model.setFilterFixedString("")
```

**Verification:**
This should properly clear the filter using the current PySide6 API methods.

### 2024-03-12: Enhanced Drag and Drop Functionality for Windows Compatibility

**Issue:** 
Despite previous improvements, the drag and drop functionality still wasn't working properly - the application showed a red crossed circle when trying to drop CSV files, and files couldn't be dropped.

**Root Cause:**
After thorough investigation, two critical issues were identified:

1. **Windows-specific URL and path handling issues**: On Windows, Qt's handling of file URLs and paths requires special attention, particularly with path formats and URL conversion.

2. **Event state management**: The event handling sequence needed restructuring to ensure proper state transitions during the drag and drop operation.

**Solution:**

1. **Improved URL and path handling**:
   ```python
   # Convert URL to local file path (different methods for robustness)
   filepath = url.toLocalFile()
   if not filepath and url.isLocalFile():
       filepath = url.path()
       # Remove leading slash on Windows if it exists
       if filepath.startswith('/') and ':' in filepath:
           filepath = filepath[1:]
   ```

2. **Enhanced event state management**:
   ```python
   # CRUCIAL: Accept the event regardless of file type at dragEnter time
   # We'll filter files later in the drop event
   if has_urls:
       event.acceptProposedAction()  # Accept the proposed action
       self._update_style(True)  # Highlight to show user something is happening
       return
   ```

3. **Comprehensive error handling and logging**:
   ```python
   try:
       # Process dropped files
       if event.mimeData().hasUrls():
           # Detailed processing with extensive logging
           # ...
   except Exception as e:
       print(f"ERROR in dropEvent: {str(e)}")
       event.ignore()
   ```

4. **Explicit drop action configuration**:
   ```python
   # Set the drop action explicitly to CopyAction
   event.setDropAction(Qt.CopyAction)
   event.acceptProposedAction()
   ```

5. **Refactored file path handling in load_csv_file**:
   ```python
   # Normalize filepath for Windows
   filepath = Path(filepath).resolve().as_posix()
   
   # More thorough file checks
   print(f"File exists: {os.path.exists(filepath)}")
   print(f"File readable: {os.access(filepath, os.R_OK)}")
   print(f"File size: {os.path.getsize(filepath) if os.path.exists(filepath) else 'N/A'}")
   ```

6. **Enhanced CSV loading with detailed diagnostics**:
   ```python
   # Try to read the first few bytes to check if file is accessible
   try:
       with open(filepath, 'rb') as f:
           first_bytes = f.read(16)
           if DataProcessor.debug:
               print(f"First bytes: {first_bytes}")
   except Exception as e:
       error_msg = f"Failed to open file: {str(e)}"
       print(error_msg)
       raise ValueError(error_msg)
   ```

**Key Improvements:**
1. Accepting ANY drag initially with URLs, then filtering by file type later in the drop event
2. Multiple fallback mechanisms for file path extraction
3. Explicit setting of drop action to CopyAction
4. Normalized file paths for cross-platform compatibility
5. Comprehensive error catching and detailed logging
6. More thorough file validation checks

**Verification:**
These additional fixes should resolve the drag and drop issues by:
1. Working around Windows-specific path handling quirks
2. Providing much more detailed logging for troubleshooting
3. Ensuring proper event state transitions during drag and drop
4. Being more robust with file handling and error recovery

### 2024-03-13: Alternative File Import Methods

**Issue:** 
Despite multiple attempts to fix the drag and drop functionality, it continued to have issues on some Windows systems, preventing users from importing CSV files.

**Root Cause:**
After extensive troubleshooting, we determined that there might be system-specific drag and drop limitations or Qt-related issues that couldn't be resolved through standard event handling approaches.

**Solution:**
Instead of continuing to troubleshoot the drag and drop issue, we implemented multiple alternative file import methods to ensure users can always import CSV files regardless of drag and drop functionality:

1. **Added explicit File menu with Import option**:
   ```python
   def setup_menu(self):
       """Set up the application menu"""
       # Create menu bar
       menu_bar = self.menuBar()
       
       # Create File menu
       file_menu = menu_bar.addMenu("&File")
       
       # Add Import action
       import_action = file_menu.addAction("&Import CSV File...")
       import_action.setShortcut("Ctrl+O")
       import_action.triggered.connect(self.open_file_dialog)
       # ...
   ```

2. **Added a prominent import button to the drop area**:
   ```python
   # Add explicit import button
   self.import_button = QPushButton("Select CSV File")
   self.import_button.clicked.connect(self.open_file_dialog)
   self.import_button.setMinimumHeight(40)
   self.import_button.setStyleSheet(f"""
       QPushButton {{
           background-color: {DARK_THEME['accent']};
           color: white;
           font-weight: bold;
           font-size: 12px;
           border-radius: 4px;
           padding: 8px 16px;
       }}
       # ...
   ```

3. **Enhanced the drop area with a clear visual document icon**:
   ```python
   # Create a QLabel with an icon for import
   self.icon_label = QLabel()
   self.icon_label.setAlignment(Qt.AlignCenter)
   
   # Create a pixmap with a document icon
   icon_font = QFont()
   icon_font.setPointSize(48)
   icon_pixmap = QPixmap(64, 64)
   # ...
   ```

4. **Updated UI instructions to clearly show all import options**:
   ```python
   instructions = QLabel(
       "Import your CSV file by dragging and dropping it below, clicking the area, or using the Import button in the File menu."
   )
   ```

5. **Maintained our existing drag and drop implementation** as a fallback, but with simplified, more targeted code.

**Key Improvements:**
1. Multiple paths to import files, not relying solely on drag and drop
2. More prominent, user-friendly UI for file importing
3. Standard file dialog approach that works reliably across all platforms
4. Standard menu shortcuts (Ctrl+O) that users are familiar with
5. Better visual cues and instructions for users

**Verification:**
This approach ensures users can import CSV files even if drag and drop functionality is problematic on their specific system. The multiple import methods provide redundancy and a better overall user experience.

## Ongoing Issues

None currently identified. 