import sys
import os
import csv
import pandas as pd
import numpy as np
import configparser
import datetime
from pathlib import Path
import matplotlib.pyplot as plt
# Define Tableau colors for charts
TABLEAU_COLORS = ['#4e79a7', '#f28e2c', '#e15759', '#76b7b2', '#59a14f', '#edc949', '#af7aa1', '#ff9da7', '#9c755f', '#bab0ab']

import traceback
# Configure matplotlib to use PySide6
import matplotlib
matplotlib.use('QtAgg')  # Use the generic Qt backend that works with PySide6
from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
import types  # Add this import for method binding
import re  # Add this import for regular expressions
import time
import json
import random
from datetime import datetime, timedelta
import tempfile

from PySide6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, 
    QTableView, QPushButton, QTabWidget, QLabel, QFileDialog,
    QComboBox, QGroupBox, QSplitter, QMessageBox, QFrame, QHeaderView,
    QLineEdit, QListWidget, QDateEdit, QCheckBox, QListWidgetItem,
    QGridLayout, QTextBrowser
)
from PySide6.QtPrintSupport import QPrinter, QPageSetupDialog
from PySide6.QtCore import (
    Qt, QAbstractTableModel, QModelIndex, Signal, QMimeData, 
    QUrl, QSize, Slot, QSortFilterProxyModel, QObject, QEvent, QTimer,
    QSettings, QStandardPaths, QDate
)
from PySide6.QtGui import (
    QStandardItemModel, QStandardItem, QDropEvent, QDragEnterEvent,
    QColor, QPalette, QFont, QIcon, QPixmap, QPainter
)

# Style constants
DARK_THEME = {
    'background': '#1A2742',  # Dark blue background similar to Total Battle
    'foreground': '#FFFFFF',  # White text for better contrast
    'accent': '#D4AF37',      # Brighter gold accent for lines and small highlights
    'accent_hover': '#F0C75A',  # Lighter gold for hover states
    'secondary': '#345995',   # Secondary blue color
    'success': '#56A64B',     # Keep green for success indicators
    'error': '#A6564B',       # Keep red for error indicators
    'card_bg': '#0D1A33',     # Darker blue for card backgrounds
    'border': '#2A3F5F',      # Medium blue for borders
    'text_disabled': '#8899AA', # Bluish gray for disabled text
    'header_bg': '#0E2145',   # Header background
    'button_gradient_top': '#1A3863',  # Top gradient for buttons
    'button_gradient_bottom': '#0B1A36',  # Bottom gradient for buttons
    'background_light': '#2A3F5F',  # Light background for report tab
}

# Set up application-level exception handling
def exception_handler(exctype, value, tb):
    """Global exception handler for the application."""
    print(f"Unhandled exception: {exctype.__name__}: {value}")
    traceback.print_tb(tb)
    
    # Show error dialog
    error_msg = QMessageBox()
    error_msg.setIcon(QMessageBox.Critical)
    error_msg.setWindowTitle("Error")
    error_msg.setText(f"An error occurred: {exctype.__name__}")
    error_msg.setInformativeText(str(value))
    error_msg.setDetailedText(''.join(traceback.format_tb(tb)))
    error_msg.exec()

# Install exception handler
sys.excepthook = exception_handler

class ConfigManager:
    """Manage application configuration settings."""

    def __init__(self, app_name="TotalBattleAnalyzer"):
        """
        Initialize the configuration manager.
        
        Args:
            app_name (str): The name of the application.
        """
        self.app_name = app_name
        self.config = {}
        self.config_dir = os.path.join(os.path.expanduser("~"), f".{app_name.lower()}")
        self.config_file = os.path.join(self.config_dir, "config.json")
        
        # Create config directory if it doesn't exist
        os.makedirs(self.config_dir, exist_ok=True)
        
        # Load the configuration
        self.load_config()
        
    @staticmethod
    def load_config():
        """
        Static method to load configuration from file.
        
        Returns:
            dict: A dictionary with configuration settings.
        """
        # Default configuration
        default_config = {
            'theme': 'dark',
            'window_size': (1200, 800),
            'recent_files': [],
            'max_recent_files': 5,
            'import_dir': os.path.join(os.getcwd(), 'import'),
            'export_dir': os.path.join(os.getcwd(), 'export'),
            'encodings': ['utf-8', 'latin1', 'cp1252', 'iso-8859-1', 'windows-1252', 'utf-8-sig']
        }
        
        # Return default config
        return default_config
    
    def load_config(self):
        """Load configuration from file."""
        # Default configuration
        self.config = {
            'theme': 'dark',
            'window_size': (1200, 800),
            'recent_files': [],
            'max_recent_files': 5,
            'import_dir': os.path.join(os.getcwd(), 'import'),
            'export_dir': os.path.join(os.getcwd(), 'export')
        }
        
        # Load from file if it exists
        if os.path.exists(self.config_file):
            try:
                with open(self.config_file, 'r') as f:
                    loaded_config = json.load(f)
                    self.config.update(loaded_config)
            except Exception as e:
                        print(f"Error loading config file: {str(e)}")
                
        # Ensure the import and export directories exist
        os.makedirs(self.config['import_dir'], exist_ok=True)
        os.makedirs(self.config['export_dir'], exist_ok=True)
        
        # Return for convenient method chaining
        return self
    
    def save_config(self):
        """Save the current configuration to file."""
        try:
            with open(self.config_file, 'w') as f:
                json.dump(self.config, f, indent=4)
        except Exception as e:
                        print(f"Error saving config file: {str(e)}")
    
    def get(self, section, key, default=None):
        """
        Get a configuration value.
        
        Args:
            section (str): The section name.
            key (str): The key within the section.
            default: The default value to return if the key is not found.
            
        Returns:
            The value for the given key, or the default if not found.
        """
        section_dict = self.config.get(section, {})
        return section_dict.get(key, default)
    
    def set(self, section, key, value):
        """
        Set a configuration value.
        
        Args:
            section (str): The section name.
            key (str): The key within the section.
            value: The value to set.
        """
        if section not in self.config:
            self.config[section] = {}
        self.config[section][key] = value
        self.save_config()
    
    def add_recent_file(self, filepath):
        """
        Add a file to the recent files list.
        
        Args:
            filepath (str): The path to the file.
        """
        if 'recent_files' not in self.config:
            self.config['recent_files'] = []
        
        # Remove if already exists
        if filepath in self.config['recent_files']:
            self.config['recent_files'].remove(filepath)
        
        # Add to the beginning
        self.config['recent_files'].insert(0, filepath)
        
        # Limit the number of recent files
        max_recent = self.config.get('max_recent_files', 5)
        if len(self.config['recent_files']) > max_recent:
            self.config['recent_files'] = self.config['recent_files'][:max_recent]
        
        self.save_config()
    
    def get_recent_files(self):
        """
        Get the list of recent files.
        
        Returns:
            list: A list of recent file paths.
        """
        return self.config.get('recent_files', [])
    
    def set_theme(self, theme):
        """
        Set the theme.
        
        Args:
            theme (str): The theme name.
        """
        self.config['theme'] = theme
        self.save_config()
    
    def get_theme(self):
        """
        Get the current theme.
        
        Returns:
            str: The theme name.
        """
        return self.config.get('theme', 'dark')
    
    def set_window_size(self, width, height):
        """
        Set the window size.
        
        Args:
            width (int): The window width.
            height (int): The window height.
        """
        self.config['window_size'] = (width, height)
        self.save_config()
    
    def get_window_size(self):
        """
        Get the window size.
        
        Returns:
            tuple: A tuple of (width, height).
        """
        return self.config.get('window_size', (1200, 800))
    
    def set_import_directory(self, directory):
        """
        Set the import directory.
        
        Args:
            directory (str): The directory path.
        """
        self.config['import_dir'] = directory
        self.save_config()
    
    def get_import_directory(self):
        """
        Get the import directory.
        
        Returns:
            str: The import directory path.
        """
        return self.config.get('import_dir', os.path.join(os.getcwd(), 'import'))
    
    def set_export_directory(self, directory):
        """
        Set the export directory.
        
        Args:
            directory (str): The directory path.
        """
        self.config['export_dir'] = directory
        self.save_config()
    
    def get_export_directory(self):
        """
        Get the export directory.
        
        Returns:
            str: The export directory path.
        """
        return self.config.get('export_dir', os.path.join(os.getcwd(), 'export'))

class StyleManager:
    @staticmethod
    def apply_dark_theme(app):
        """Apply Total Battle-inspired theme to the entire application"""
        # Define our colors
        colors = DARK_THEME
        
        # Create a palette for the application
        dark_palette = QPalette()
        
        # Set colors
        dark_palette.setColor(QPalette.Window, QColor(colors['background']))
        dark_palette.setColor(QPalette.WindowText, QColor(colors['foreground']))
        dark_palette.setColor(QPalette.Base, QColor(colors['card_bg']))
        dark_palette.setColor(QPalette.AlternateBase, QColor(colors['background']))
        dark_palette.setColor(QPalette.ToolTipBase, QColor(colors['foreground']))
        dark_palette.setColor(QPalette.ToolTipText, QColor(colors['foreground']))
        dark_palette.setColor(QPalette.Text, QColor(colors['foreground']))
        dark_palette.setColor(QPalette.Button, QColor(colors['card_bg']))
        dark_palette.setColor(QPalette.ButtonText, QColor(colors['foreground']))
        dark_palette.setColor(QPalette.BrightText, QColor(colors['accent']))
        dark_palette.setColor(QPalette.Link, QColor(colors['accent']))
        dark_palette.setColor(QPalette.Highlight, QColor(colors['accent']))
        dark_palette.setColor(QPalette.HighlightedText, QColor(colors['foreground']))
        dark_palette.setColor(QPalette.Disabled, QPalette.Text, QColor(colors['text_disabled']))
        dark_palette.setColor(QPalette.Disabled, QPalette.ButtonText, QColor(colors['text_disabled']))
        
        # Apply palette
        app.setPalette(dark_palette)
        
        # Apply stylesheet for custom styling
        app.setStyleSheet(f"""
            /* Global Styles */
            QWidget {{
                background-color: {colors['background']};
                color: {colors['foreground']};
                font-family: 'Segoe UI', Arial, sans-serif;
            }}
            
            /* Main Window */
            QMainWindow {{
                background-color: {colors['background']};
                border: none;
            }}
            
            /* Menu Bar */
            QMenuBar {{
                background-color: {colors['header_bg']};
                color: {colors['foreground']};
                border-bottom: 1px solid {colors['border']};
                padding: 4px;
            }}
            
            QMenuBar::item {{
                background-color: transparent;
                padding: 6px 12px;
                border-radius: 4px;
            }}
            
            QMenuBar::item:selected {{
                background-color: {colors['accent']};
                color: {colors['background']};
            }}
            
            QMenuBar::item:pressed {{
                background-color: {colors['accent_hover']};
                color: {colors['background']};
            }}
            
            /* Menu */
            QMenu {{
                background-color: {colors['card_bg']};
                border: 1px solid {colors['border']};
                padding: 4px;
            }}
            
            QMenu::item {{
                padding: 4px 20px 4px 20px;
                border-radius: 2px;
            }}
            
            QMenu::item:selected {{
                background-color: {colors['accent']};
                color: {colors['background']};
            }}
            
            QMenu::separator {{
                height: 1px;
                background-color: {colors['border']};
                margin: 4px 8px;
            }}
            
            /* Tabs */
            QTabWidget::pane {{
                border: 1px solid {colors['border']};
                background-color: {colors['background']};
            }}
            
            QTabBar::tab {{
                background-color: {colors['background']};
                padding: 8px 16px;
                margin-right: 2px;
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
                border: 1px solid {colors['border']};
                border-bottom: none;
            }}
            
            QTabBar::tab:selected {{
                background-color: {colors['card_bg']};
                border-bottom: 2px solid {colors['accent']};
                color: {colors['accent']};
                font-weight: bold;
            }}
            
            QTabBar::tab:!selected {{
                margin-top: 2px;
                color: {colors['foreground']};
            }}
            
            QTabBar::tab:disabled {{
                color: {colors['text_disabled']};
                background-color: {colors['background']};
            }}
            
            /* Tables */
            QTableView {{
                gridline-color: {colors['border']};
                background-color: {colors['card_bg']};
                alternate-background-color: {colors['background']};
                selection-background-color: {colors['accent']};
                selection-color: {colors['background']};
                border: 1px solid {colors['border']};
            }}
            
            QTableView::item {{
                padding: 4px;
                border-bottom: 1px solid {colors['border']};
            }}
            
            QHeaderView::section {{
                background-color: {colors['header_bg']};
                padding: 6px;
                border: none;
                border-right: 1px solid {colors['border']};
                border-bottom: 1px solid {colors['border']};
                font-weight: bold;
            }}
            
            /* Buttons */
            QPushButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                         stop:0 {colors['button_gradient_top']}, 
                                         stop:1 {colors['button_gradient_bottom']});
                border: 1px solid {colors['accent']};
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }}
            
            QGroupBox::title {{
                subcontrol-origin: margin;
                subcontrol-position: top left;
                padding: 0 5px;
                background-color: {DARK_THEME['header_bg']};
                border: 1px solid {DARK_THEME['border']};
                border-radius: 3px;
            }}
            
            /* Label styles */
            QLabel {{
                color: {DARK_THEME['foreground']};
            }}
            
            QLabel[title="true"] {{
                font-size: 16px;
                font-weight: bold;
                color: {DARK_THEME['accent']};
            }}
            
            /* Splitter */
            QSplitter::handle {{
                background-color: {DARK_THEME['border']};
            }}
            
            QSplitter::handle:horizontal {{
                width: 1px;
            }}
            
            QSplitter::handle:vertical {{
                height: 1px;
            }}
            
            /* Status Bar */
            QStatusBar {{
                background-color: {DARK_THEME['header_bg']};
                color: {DARK_THEME['foreground']};
                border-top: 1px solid {DARK_THEME['border']};
            }}
            
            QStatusBar QLabel {{
                padding: 3px;
            }}
            
            /* Frame */
            QFrame[frameShape="4"], QFrame[frameShape="5"] {{
                color: {DARK_THEME['border']};
            }}
        """)

class CustomTableModel(QAbstractTableModel):
    """Custom table model for PySide6 TableView"""
    
    def __init__(self, data=None, headers=None):
        super().__init__()
        self._data = data if data is not None else []
        self._headers = headers if headers is not None else []
        
    def data(self, index, role):
        if role == Qt.DisplayRole:
            return str(self._data[index.row()][index.column()])
        elif role == Qt.BackgroundRole:
            # Alternate row colors for better readability
            if index.row() % 2 == 0:
                return QColor(DARK_THEME['card_bg'])
            else:
                return QColor(DARK_THEME['background'])
        elif role == Qt.TextAlignmentRole:
            # Align numbers to the right, text to the left
            value = self._data[index.row()][index.column()]
            if isinstance(value, (int, float)):
                return Qt.AlignRight | Qt.AlignVCenter
            return Qt.AlignLeft | Qt.AlignVCenter
            
        return None
        
    def rowCount(self, parent=QModelIndex()):
        return len(self._data)
        
    def columnCount(self, parent=QModelIndex()):
        if self._data:
            return len(self._data[0])
        return len(self._headers)
        
    def headerData(self, section, orientation, role):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole and section < len(self._headers):
            return self._headers[section]
        return None
    
    def setData(self, data, headers):
        self.beginResetModel()
        self._data = data
        self._headers = headers
        self.endResetModel()
        
    def sort(self, column, order):
        """Sort table by given column number."""
        self.beginResetModel()
        self._data = sorted(self._data, key=lambda x: x[column], reverse=(order == Qt.DescendingOrder))
        self.endResetModel()

class MplCanvas(FigureCanvas):
    """Canvas for matplotlib charts"""
    
    def __init__(self, parent=None, width=5, height=4, dpi=100):
        """Initialize the canvas with dark theme"""
        plt.style.use('dark_background')
        self.fig = Figure(figsize=(width, height), dpi=dpi)
        self.fig.patch.set_facecolor(DARK_THEME['card_bg'])
        
        self.axes = self.fig.add_subplot(111)
        self.axes.set_facecolor(DARK_THEME['card_bg'])
        self.axes.tick_params(colors=DARK_THEME['foreground'], labelsize=9)
        self.axes.xaxis.label.set_color(DARK_THEME['foreground'])
        self.axes.yaxis.label.set_color(DARK_THEME['foreground'])
        self.axes.title.set_color(DARK_THEME['accent'])
        
        # Set spines (chart borders) to the border color
        for spine in self.axes.spines.values():
            spine.set_color(DARK_THEME['border'])
        
        # Enhanced color palette for better visualizations
        self.chart_colors = [
            '#FFD700',                   # Gold
            '#4B7AA6',                   # Light blue
            '#A6564B',                   # Red
            '#56A64B',                   # Green 
            '#6C567B',                   # Purple
            '#AA8239',                   # Dark gold
            '#4BA657',                   # Teal
            '#A64B98',                   # Pink
            '#7D6A3B',                   # Bronze
            '#E5C07B',                   # Light gold
        ]
        
        # Define style presets for different chart types
        self.style_presets = {
            'default': {
                'grid': True,
                'grid_alpha': 0.3,
                'grid_linestyle': '--',
                'tick_size': 9,
                'label_size': 10,
                'title_size': 14
            },
            'minimal': {
                'grid': False,
                'tick_size': 8,
                'label_size': 9,
                'title_size': 12
            },
            'detailed': {
                'grid': True,
                'grid_alpha': 0.5,
                'grid_linestyle': '-',
                'tick_size': 10,
                'label_size': 11,
                'title_size': 16
            }
        }
        
        # Default style
        self.current_style = 'default'
        
        super().__init__(self.fig)
        self.setParent(parent)
    
    def apply_style(self, style_name='default'):
        """Apply a predefined style to the chart"""
        if style_name not in self.style_presets:
            style_name = 'default'
            
        self.current_style = style_name
        style = self.style_presets[style_name]
        
        # Apply grid settings
        self.axes.grid(style.get('grid', True), 
                     alpha=style.get('grid_alpha', 0.3),
                     linestyle=style.get('grid_linestyle', '--'))
        
        # Apply font sizes
        self.axes.tick_params(labelsize=style.get('tick_size', 9))
        self.axes.xaxis.label.set_fontsize(style.get('label_size', 10))
        self.axes.yaxis.label.set_fontsize(style.get('label_size', 10))
        self.axes.title.set_fontsize(style.get('title_size', 14))
        
        # Redraw
        self.draw()
    
    def save_figure(self, filepath, dpi=300):
        """Save the current figure to a file"""
        self.fig.savefig(filepath, dpi=dpi, bbox_inches='tight', facecolor=self.fig.get_facecolor())
        return filepath

class DropArea(QWidget):
    """Custom widget for handling file drops"""
    
    fileDropped = Signal(str)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        
        # Debug flag for verbose logging
        self.debug = True
        
        # Get access to the main window's config manager
        self.main_window = self.get_main_window()
        
        self.setAcceptDrops(True)
        self.setMinimumHeight(200)
        
        # Create layout
        layout = QVBoxLayout()
        
        # Add a label and icon
        self.label = QLabel("Please select a CSV File here")
        self.label.setAlignment(Qt.AlignCenter)
        self.label.setProperty("titleLabel", "true")
        
        self.icon_label = QLabel("📄")
        self.icon_label.setStyleSheet(f"font-size: 48px; color: {DARK_THEME['accent']};")
        self.icon_label.setAlignment(Qt.AlignCenter)
        
        # Add alternative method text
        self.alt_label = QLabel("or")
        self.alt_label.setAlignment(Qt.AlignCenter)
        
        # Add button for file selection
        self.select_button = QPushButton("Select CSV File")
        self.select_button.clicked.connect(self.open_file_dialog)
        
        # Add to layout
        layout.addWidget(self.label)
        layout.addWidget(self.icon_label)
        layout.addWidget(self.alt_label)
        layout.addWidget(self.select_button, 0, Qt.AlignCenter)
        
        self.setLayout(layout)
        self._update_style(False)
    
    def get_main_window(self):
        """Find the main window parent"""
        parent = self.parent()
        while parent is not None:
            if isinstance(parent, MainWindow):
                return parent
            parent = parent.parent()
        return None

    def open_file_dialog(self):
        """Open a file dialog to select a CSV file"""
        if self.main_window and hasattr(self.main_window, 'config_manager'):
            # Get the import directory from config
            start_dir = self.main_window.config_manager.get_last_used_directory()
        else:
            # Fallback to current directory if config manager is not available
            start_dir = ""
        
        filepath, _ = QFileDialog.getOpenFileName(
            self, "Open CSV File", start_dir, "CSV Files (*.csv)"
        )
        
        if filepath:
            if self.debug:
                print(f"File selected via dialog: {filepath}")
                
            # Update last used directory in config if possible
            if self.main_window and hasattr(self.main_window, 'config_manager'):
                self.main_window.config_manager.set_last_used_directory(str(Path(filepath).parent))
                
            self.fileDropped.emit(filepath)
    
    def _update_style(self, highlight=False):
        """Update the border style of the drop area"""
        border_color = DARK_THEME['accent'] if highlight else DARK_THEME['border']
        bg_color = DARK_THEME['card_bg'] if not highlight else DARK_THEME['background']
        self.setStyleSheet(f"""
            QWidget {{
                border: 2px dashed {border_color};
                border-radius: 8px;
                background-color: {bg_color};
                padding: 16px;
            }}
            
            QLabel {{
                border: none;
                background-color: transparent;
                padding: 0px;
            }}
            
            QLabel[titleLabel="true"] {{
                color: {DARK_THEME['accent']};
                font-size: 16px;
                font-weight: bold;
            }}
        """)

    def mousePressEvent(self, event):
        """Handle mouse press events to provide button-like interaction"""
        if event.button() == Qt.LeftButton:
            self.open_file_dialog()
            
class ImportArea(QWidget):
    """Widget for importing CSV files via file selection"""
    
    fileSelected = Signal(str)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        
        # Debug flag for verbose logging
        self.debug = True
        
        # Get access to the main window's config manager
        self.main_window = self.get_main_window()
        
        layout = QVBoxLayout()
        
        self.label = QLabel("Import CSV File")
        self.label.setAlignment(Qt.AlignCenter)
        self.label.setProperty("titleLabel", "true")
        
        # Create and add document icon
        icon_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "document_icon.png")
        
        # If the icon file exists, use it, otherwise create a text label
        if os.path.exists(icon_path):
            self.icon_label = QLabel()
            self.icon_label.setPixmap(QPixmap(icon_path).scaled(48, 48, Qt.KeepAspectRatio, Qt.SmoothTransformation))
            self.icon_label.setAlignment(Qt.AlignCenter)
            self.icon_label.setProperty("iconLabel", "true")
        else:
            # Create a gold-colored document icon as text
            self.icon_label = QLabel("📄")
            self.icon_label.setStyleSheet(f"font-size: 48px; color: {DARK_THEME['accent']};")
            self.icon_label.setAlignment(Qt.AlignCenter)
            self.icon_label.setProperty("iconLabel", "true")
        
        # Add instructions text
        self.instruction_label = QLabel("Click here or use File > Import CSV to load your data")
        self.instruction_label.setAlignment(Qt.AlignCenter)
        self.instruction_label.setProperty("instructionLabel", "true")
        
        # Add file select button with gold gradient
        self.select_button = QPushButton("Select CSV File")
        self.select_button.setMinimumWidth(150)
        self.select_button.clicked.connect(self.open_file_dialog)
        
        # Create layout
        layout.addWidget(self.label)
        layout.addWidget(self.icon_label)
        layout.addWidget(self.instruction_label)
        layout.addSpacing(10)
        layout.addWidget(self.select_button, 0, Qt.AlignCenter)
        layout.setContentsMargins(20, 20, 20, 20)
        
        self.setLayout(layout)
        self._update_style()
        
        # Make the widget clickable for file selection
        self.setCursor(Qt.PointingHandCursor)
    
    def get_main_window(self):
        """Find the main window parent"""
        parent = self.parent()
        while parent is not None:
            if isinstance(parent, MainWindow):
                return parent
            parent = parent.parent()
        return None

    def open_file_dialog(self):
        """Open file dialog to select a CSV file"""
        if self.main_window and hasattr(self.main_window, 'config_manager'):
            # Get the import directory from config
            start_dir = self.main_window.config_manager.get_last_used_directory()
        else:
            # Fallback to current directory if config manager is not available
            start_dir = ""
        
        filepath, _ = QFileDialog.getOpenFileName(
            self, "Open CSV File", start_dir, "CSV Files (*.csv)"
        )
        
        if filepath:
            if self.debug:
                print(f"File selected via dialog: {filepath}")
                
            # Update last used directory in config if possible
            if self.main_window and hasattr(self.main_window, 'config_manager'):
                self.main_window.config_manager.set_last_used_directory(str(Path(filepath).parent))
                
            self.fileSelected.emit(filepath)
    
    def _update_style(self):
        """Update the styling of the import area"""
        self.setStyleSheet(f"""
            QWidget {{
                border: 2px dashed {DARK_THEME['accent']};
                border-radius: 8px;
                background-color: {DARK_THEME['card_bg']};
                padding: 16px;
            }}
            
            QLabel[iconLabel="true"] {{
                border: none;
                background-color: transparent;
                padding: 0px;
            }}
            
            QLabel[titleLabel="true"] {{
                border: none;
                background-color: transparent;
                color: {DARK_THEME['accent']};
                font-size: 16px;
                font-weight: bold;
                padding: 0px;
            }}
            
            QLabel[instructionLabel="true"] {{
                border: none;
                background-color: transparent;
                padding: 0px;
                color: {DARK_THEME['foreground']};
            }}
        """)

    def mousePressEvent(self, event):
        """Handle mouse press events to provide button-like interaction"""
        if event.button() == Qt.LeftButton:
            self.open_file_dialog()

class DataProcessor:
    """Class to handle data processing logic"""
    
    # Debug flag
    debug = True
    
    @staticmethod
    def load_csv(filepath, encodings=None):
        """
        Load a CSV file and return a pandas DataFrame with enhanced error handling.
        
        Args:
            filepath (str): Path to the CSV file
            encodings (list, optional): List of encodings to try. Defaults to None.
            
        Returns:
            tuple: (DataFrame, success, error_message)
        """
        print("=== DataProcessor.load_csv ===")
        print(f"Processing filepath: {filepath}")
        print(f"Type of filepath: {type(filepath)}")
        print(f"DataProcessor.load_csv: Processing {filepath}")
        
        # Check if the file exists
        file_exists = os.path.exists(filepath)
        print(f"File exists check: {file_exists}")
        
        if not file_exists:
            return None, False, f"File not found: {filepath}"
        
        # Get file size
        file_size = os.path.getsize(filepath)
        print(f"File size: {file_size} bytes")
                
        # Check if file is empty
        if file_size == 0:
            return None, False, "File is empty"
            
        # Try to detect file encoding by reading the first few bytes
        try:
            with open(filepath, 'rb') as f:
                raw_data = f.read(min(file_size, 1024))  # Read first 1KB or entire file
                print(f"First bytes: {raw_data[:50]}")  # Only print first 50 bytes
                print(f"First bytes (hex): {raw_data.hex()[:50]}")  # Show first 50 hex chars
                
                # Check if it looks like binary data
                is_likely_text = all(b in range(32, 127) or b in (9, 10, 13) for b in raw_data[:20])
                print(f"First bytes look like valid ASCII/text data: {is_likely_text}")
                
                # Look for signs of German umlauts in the file
                has_umlauts = any(b in [196, 214, 220, 223, 228, 246, 252] for b in raw_data)
                
                # Also check for garbled umlaut patterns (e.g., 'Ã¤' instead of 'ä')
                garbled_patterns = [b'\xc3\xa4', b'\xc3\xb6', b'\xc3\xbc', b'\xc3\x9f']
                has_garbled_umlauts = any(pattern in raw_data for pattern in garbled_patterns)
                
                if has_umlauts:
                    print("Detected potential German umlauts in extended content")
                if has_garbled_umlauts:
                    print("Detected garbled German umlaut patterns")
                    
        except Exception as e:
            print(f"Error reading file for encoding detection: {str(e)}")
            print(f"Error reading file for encoding detection: {str(e)}")
            has_umlauts = False
            has_garbled_umlauts = False
        # Set up list of encodings to try
        if encodings is None:
            # Default encodings to try
            if has_umlauts or has_garbled_umlauts:
                # If German characters are detected, prioritize German-friendly encodings
                encodings = ['latin1', 'cp1252', 'iso-8859-1', 'windows-1252', 'utf-8', 'utf-8-sig']
                print("Using German-prioritized encodings due to detected umlauts")
            else:
                encodings = ['utf-8', 'latin1', 'cp1252', 'iso-8859-1', 'windows-1252', 'utf-8-sig']
                print("Using default encoding list")
        
        # Variables to hold errors from all attempts
        all_errors = []
        df = None
        
        # Try different encodings
        for encoding in encodings:
            try:
                print(f"Trying to load with encoding: {encoding}")
                df = pd.read_csv(filepath, encoding=encoding)
                successful_encoding = encoding
                print(f"Successfully loaded with encoding: {encoding}")
                break
            except UnicodeDecodeError as e:
                print(f"UnicodeDecodeError with {encoding}: {str(e)}")
            except Exception as e:
                        print(f"Error with {encoding}: {str(e)}")
        
        if df is None:
            return None, False, "Failed to load CSV with any of the attempted encodings"
            
        # Print DataFrame info
        print(f"DataFrame shape: {df.shape}")
        print(f"Columns: {list(df.columns)}")
        
        if len(df) > 0:
            print(f"First row: {list(df.iloc[0])}")
            print("\nSample data (first 5 rows):")
            print(df.head())
        
        # Detect and fix encoding issues with German umlauts
        if 'PLAYER' in df.columns:
            # Check for garbled umlauts (common signs of encoding mismatch)
            sample_players = df['PLAYER'].head(100).astype(str).tolist()
            has_garbled_umlauts = any(re.search(r'([Ã][¤äö]|[Ã][–Ö]|[Ã][¼ü]|[ÃŸß])', player) for player in sample_players)
            
            # Special chars that would suggest proper encoding or garbled chars
            has_umlauts = any(re.search(r'[äöüÄÖÜß]', player) for player in sample_players)
            
            if has_garbled_umlauts:
                print("Data contains garbled German umlauts (encoding mismatch detected)")
                # Find examples of garbled text
                for player in sample_players:
                    if re.search(r'([Ã][¤äö]|[Ã][–Ö]|[Ã][¼ü]|[ÃŸß])', player):
                        correct_player = player
                        # Try to fix common patterns
                        correct_player = correct_player.replace('Ã¤', 'ä')
                        correct_player = correct_player.replace('Ã¶', 'ö')
                        correct_player = correct_player.replace('Ã¼', 'ü')
                        correct_player = correct_player.replace('Ã„', 'Ä')
                        correct_player = correct_player.replace('Ã–', 'Ö')
                        correct_player = correct_player.replace('Ãœ', 'Ü')
                        correct_player = correct_player.replace('ÃŸ', 'ß')
                        print(f"Found misencoded '{player}' - this should be '{correct_player}'")
                
                print("Attempting to fix encoding for the PLAYER column")
                # Apply corrections to the whole column
                df['PLAYER'] = df['PLAYER'].str.replace('Ã¤', 'ä', regex=True)
                df['PLAYER'] = df['PLAYER'].str.replace('Ã¶', 'ö', regex=True)
                df['PLAYER'] = df['PLAYER'].str.replace('Ã¼', 'ü', regex=True)
                df['PLAYER'] = df['PLAYER'].str.replace('Ã„', 'Ä', regex=True)
                df['PLAYER'] = df['PLAYER'].str.replace('Ã–', 'Ö', regex=True)
                df['PLAYER'] = df['PLAYER'].str.replace('Ãœ', 'Ü', regex=True)
                df['PLAYER'] = df['PLAYER'].str.replace('ÃŸ', 'ß', regex=True)
            
            print(f"Data contains German umlauts (properly formatted or garbled): {has_umlauts or has_garbled_umlauts}")
        
        # Drop any extra columns (if default columns are defined)
        expected_columns = ['DATE', 'PLAYER', 'SOURCE', 'CHEST', 'SCORE']
        extra_columns = [col for col in df.columns if col not in expected_columns]
        
        if extra_columns:
            print(f"Dropping extra columns: {extra_columns}")
            df = df.drop(columns=extra_columns)
        
        print("=== CSV loaded successfully ===")
        return df, True, ""
    
    @staticmethod
    def analyze_data(df):
        """Process data according to requirements and return processed DataFrames"""
        # Calculate total score per player (main goal)
        player_totals = df.groupby('PLAYER')['SCORE'].sum().reset_index()
        player_totals = player_totals.sort_values('SCORE', ascending=False)
        
        # Calculate scores by chest type
        chest_totals = df.groupby('CHEST')['SCORE'].sum().reset_index()
        chest_totals = chest_totals.sort_values('SCORE', ascending=False)
        
        # Calculate scores by source
        source_totals = df.groupby('SOURCE')['SCORE'].sum().reset_index()
        source_totals = source_totals.sort_values('SCORE', ascending=False)
        
        # Calculate scores by date
        date_totals = df.groupby('DATE')['SCORE'].sum().reset_index()
        date_totals = date_totals.sort_values('DATE')
        
        # Calculate average scores
        player_avg = df.groupby('PLAYER')['SCORE'].mean().reset_index()
        player_avg = player_avg.sort_values('SCORE', ascending=False)
        player_avg['SCORE'] = player_avg['SCORE'].round(2)
        
        # Calculate number of chests per player
        player_counts = df.groupby('PLAYER').size().reset_index(name='COUNT')
        player_counts = player_counts.sort_values('COUNT', ascending=False)
        
        # Most frequent chest types per player
        player_chest_freq = df.groupby(['PLAYER', 'CHEST']).size().reset_index(name='COUNT')
        
        # Create Player Overview (new)
        # Start with base player data: total score and chest count
        player_overview = player_totals.merge(player_counts, on='PLAYER')
        player_overview = player_overview.rename(columns={'SCORE': 'TOTAL_SCORE', 'COUNT': 'CHEST_COUNT'})
        
        # Get the scores for each source type per player (instead of chest type)
        source_type_scores = df.pivot_table(
            index='PLAYER', 
            columns='SOURCE',  # Changed from CHEST to SOURCE
            values='SCORE', 
            aggfunc='sum',
            fill_value=0
        ).reset_index()
        
        # Merge source type scores with player overview
        player_overview = player_overview.merge(source_type_scores, on='PLAYER')
        
        # Sort by total score
        player_overview = player_overview.sort_values('TOTAL_SCORE', ascending=False)
        
        return {
            'player_totals': player_totals,
            'chest_totals': chest_totals,
            'source_totals': source_totals,
            'date_totals': date_totals,
            'player_avg': player_avg,
            'player_counts': player_counts,
            'player_chest_freq': player_chest_freq,
            'player_overview': player_overview,  # Add the new view
            'raw_data': df
        }

class MainWindow(QMainWindow):
    """Main application window."""
    
    def __init__(self):
        """Initialize the main window and setup the UI."""
        super().__init__()
        
        # Setup window properties
        self.setWindowTitle("Total Battle Analyzer")
        self.setMinimumSize(1000, 700)  # Set reasonable minimum size
        
        # Initialize variables
        self.raw_data = None
        self.raw_data_proxy_model = None
        self.analysis_results = None
        self.filtered_analysis_results = None
        self.chart_figure = None
        
        # Load configuration
        self.config_manager = ConfigManager()
        
        # Set the import and export directories from config
        self.import_dir = self.config_manager.get('General', 'import_directory', os.path.join(os.getcwd(), 'import'))
        self.export_dir = self.config_manager.get('General', 'export_directory', os.path.join(os.getcwd(), 'export'))
        
        # Ensure directories exist
        os.makedirs(self.import_dir, exist_ok=True)
        os.makedirs(self.export_dir, exist_ok=True)
        
        # Apply dark theme first explicitly to ensure it's activated
        StyleManager.apply_dark_theme(QApplication.instance())
        
        # Set up the UI
        self.setup_ui()
        
        # Initialize tabs as disabled except for Import
        self.init_tab_states()
        
        # Apply theme to this window as well
        self.setPalette(QApplication.instance().palette())
        
        # Set window state for proper visibility
        self.setWindowState(Qt.WindowActive)
        self.activateWindow()
        self.raise_()
        
        # Print debug info
        print(f"ImportDir: {self.import_dir}")
        print(f"ExportDir: {self.export_dir}")
    
    def show_error_dialog(self, title, message):
        """Show an error dialog with the specified title and message."""
        QMessageBox.critical(self, title, message)
    
    def init_tab_states(self):
        """Initialize tab states - only enable Import tab initially."""
        # Enable only the Import tab (index 0) initially
        if hasattr(self, 'tabs') and self.tabs is not None:
            for i in range(1, self.tabs.count()):
                self.tabs.setTabEnabled(i, False)
            
            # Show a message
            self.statusBar().showMessage("Please import a CSV file to enable analysis features.")
        else:
            print("Warning: Tabs widget not initialized yet.")
    
    def load_csv_file(self, filepath=None):
        """
        Load a CSV file and process the data.
        
        Args:
            filepath (str, optional): Path to the CSV file. If not provided, a file dialog will be shown.
            
        Returns:
            bool: True if the file was loaded successfully, False otherwise.
        """
        try:
            # If filepath is not provided, show a file dialog
            if filepath is None:
                options = QFileDialog.Options()
                filepath, _ = QFileDialog.getOpenFileName(
                    self, "Open CSV File", self.import_dir, "CSV Files (*.csv);;All Files (*)", options=options
                )
                if not filepath:
                    self.statusBar().showMessage("No file selected.")
                    return False
                    
            print(f"File selected via dialog: {filepath}")
            
            # Validate file existence and size    
            print(f"Attempting to load CSV file: {filepath}")
            if not os.path.exists(filepath):
                self.show_error_dialog("File Error", f"The file {filepath} does not exist.")
                print(f"File exists: False")
                return False
                
            file_size = os.path.getsize(filepath)
            print(f"File exists: True")
            print(f"File size: {file_size} bytes")
            
            if file_size == 0:
                self.show_error_dialog("File Error", f"The file {filepath} is empty.")
                return False
                
            # Try to load the file
            df, success, error_message = DataProcessor.load_csv(filepath)
            
            if not success:
                self.show_error_dialog("Load Error", f"Failed to load the file: {error_message}")
                return False
                
            if df is None or df.empty:
                self.show_error_dialog("Data Error", "The loaded file does not contain any data.")
                return False
                
            # Store the loaded DataFrame for later use - this is critical!
            self.raw_data = df
                
            # Process the loaded data
            print("\nCreating new raw data model")
            
            # Prepare data for the table model
            headers = df.columns.tolist()
            data = [row.tolist() for _, row in df.iterrows()]
            
            # Create the model
            self.data_model = CustomTableModel(data, headers)
            
            # Create a proxy model for filtering
            self.raw_data_proxy_model = QSortFilterProxyModel()
            self.raw_data_proxy_model.setSourceModel(self.data_model)
            
            # Add to recent files list
            self.config_manager.add_recent_file(filepath)
            
            # Update the UI
            if hasattr(self, 'file_label'):
                self.file_label.setText(f"Current File: {os.path.basename(filepath)}")
            
            # Update status bar
            self.statusBar().showMessage(f"Loaded {len(df)} records from {os.path.basename(filepath)}")
            
            # Save the current filepath
            self.current_filepath = filepath
            
            # Setup raw data view
            self.raw_data_table.setModel(self.raw_data_proxy_model)
            
            # Create analysis data
            print("About to call analyze_data")
            self.analyze_data()
            print("analyze_data completed successfully")
            
            # Populate filter column dropdown
            print("About to call populate_filter_columns_dropdown")
            self.populate_filter_columns_dropdown()
            print("populate_filter_columns_dropdown completed successfully")
            
            # Update date range controls based on data
            print("About to call update_date_range_from_data")
            self.update_date_range_from_data()
            print("update_date_range_from_data completed successfully")
            
            # Enable all tabs
            print("About to enable all tabs")
            for i in range(self.tabs.count()):
                self.tabs.setTabEnabled(i, True)
            print("All tabs enabled successfully")
            
            # Show the raw data view by default
            print("About to set current tab to Analysis")
            self.tabs.setCurrentIndex(1)  # Analysis tab
            print("Current tab set to Analysis successfully")
            
            # Select "Player Overview" by default in the analysis view dropdown
            print("About to set default analysis view to Player Overview")
            player_overview_index = self.analysis_selector.findText("Player Overview")
            if player_overview_index >= 0:
                self.analysis_selector.setCurrentIndex(player_overview_index)
            print("Default analysis view set successfully")
                
            # Make sure analysis data is processed and displayed
            print("About to call update_analysis_view")
            self.update_analysis_view()
            print("update_analysis_view completed successfully")
            
            # Force initialization of the analysis view with dummy filter application
            # This ensures everything is set up correctly without requiring user interaction
            print("Ensuring analysis view is properly initialized by applying initial filter")
            try:
                # Set up a dummy filter that shows all data
                if hasattr(self, 'analysis_show_value_selection') and hasattr(self, 'analysis_value_list'):
                    # Make sure value selection is not checked to avoid complexity
                    self.analysis_show_value_selection.setChecked(False)
                    
                # Apply filter to trigger proper view initialization
                self.filter_analysis_data()
                print("Initial filter applied successfully")
            except Exception as e:
                print(f"Error during initial filter application: {str(e)}")
                import traceback
                traceback.print_exc()
                # Continue even if this fails - it's just a helper
                
            # Update filter options
            print("About to call update_filter_options")
            self.update_filter_options()
            print("update_filter_options completed successfully")
            
            print("load_csv_file completed successfully")
            return True
            
        except Exception as e:
            print(f"Exception in load_csv_file: {str(e)}")
            traceback.print_exc()
            self.show_error_dialog("Load Error", f"An error occurred while loading the file: {str(e)}")
            return False
    
    def setup_ui(self):
        """Set up the application's main user interface"""
        # Set window properties
        self.setWindowTitle("Total Battle Analyzer")
        self.setMinimumSize(900, 700)
        
        # Create central widget and main layout
        central_widget = QWidget()
        main_layout = QVBoxLayout(central_widget)
        main_layout.setContentsMargins(10, 10, 10, 10)
        main_layout.setSpacing(10)
        
        # Create application title with gold styling
        title_layout = QHBoxLayout()
        title_label = QLabel("Total Battle Analyzer")
        title_label.setProperty("title", "true")
        title_label.setStyleSheet(f"""
            font-size: 22px;
            font-weight: bold;
            color: {DARK_THEME['accent']};
            padding: 10px;
            border-bottom: 2px solid {DARK_THEME['accent']};
        """)
        title_label.setAlignment(Qt.AlignCenter)
        title_layout.addWidget(title_label)
        main_layout.addLayout(title_layout)
        
        # Create tab widget and add to layout
        self.tabs = QTabWidget()
        self.tabs.setTabPosition(QTabWidget.North)
        self.tabs.setMovable(False)
        
        # Create tabs
        self.setup_import_tab()
        self.setup_raw_data_tab()
        self.setup_analysis_tab()
        self.setup_charts_tab()
        self.setup_report_tab()
        
        # Add tabs to widget
        main_layout.addWidget(self.tabs)
        
        # Create status bar
        self.status_bar = self.statusBar()
        self.status_bar.showMessage("Ready")
        
        # Set central widget
        self.setCentralWidget(central_widget)
        
        # Set up the menu bar
        self.setup_menu()
        
        # Disable all tabs except Import tab initially
        for i in range(1, self.tabs.count()):
            self.tabs.setTabEnabled(i, False)
            
        # Show a message that tabs will be enabled after data is loaded
        self.statusBar().showMessage("Please import a CSV file to enable analysis features", 5000)
    
    def setup_menu(self):
        """Set up the application menu"""
        # Create menu bar
        menu_bar = self.menuBar()
        
        # Create File menu
        file_menu = menu_bar.addMenu("&File")
        
        # Add Import action
        import_action = file_menu.addAction("&Import CSV File...")
        import_action.setShortcut("Ctrl+O")
        import_action.triggered.connect(self.open_file_dialog)
        
        # Add Export action
        export_action = file_menu.addAction("&Export Results...")
        export_action.setShortcut("Ctrl+S")
        export_action.triggered.connect(self.export_current_analysis)
        
        # Add Exit action
        exit_action = file_menu.addAction("E&xit")
        exit_action.setShortcut("Ctrl+Q")
        exit_action.triggered.connect(self.close)
        
        # Create Help menu
        help_menu = menu_bar.addMenu("&Help")
        
        # Add About action
        about_action = help_menu.addAction("&About")
        about_action.triggered.connect(self.show_about_dialog)
    
    def open_file_dialog(self):
        """Open a file dialog to select a CSV file"""
        # Get the last used directory from config
        start_dir = self.config_manager.get_last_used_directory()
        
        filepath, _ = QFileDialog.getOpenFileName(
            self, "Open CSV File", start_dir, "CSV Files (*.csv)"
        )
        
        if filepath:
            # Save the directory for next time
            self.config_manager.set_last_used_directory(str(Path(filepath).parent))
            self.load_csv_file(filepath)
    
    def show_about_dialog(self):
        """Show the about dialog"""
        QMessageBox.about(
            self, 
            "About Total Battle Analyzer",
            """
            <h1>Total Battle Analyzer</h1>
            <p>A tool for analyzing data from the Total Battle game.</p>
            <p>Version 1.0</p>
            """
        )
    
    def setup_import_tab(self):
        """Setup the import tab UI"""
        import_tab = QWidget()
        layout = QVBoxLayout()
        
        # Create import instructions
        info_group = QGroupBox("Import Instructions")
        info_layout = QVBoxLayout()
        
        instructions = QLabel(
            "To import data from a CSV file:\n"
            "1. Click the 'Select CSV File' button below\n"
            "2. Or use File → Import CSV... from the menu (Ctrl+O)\n\n"
            "The CSV file MUST contain ALL of the following columns:\n"
            "DATE, PLAYER, SOURCE, CHEST, SCORE\n\n"
            "Files missing any of these columns will be rejected.\n"
            "Any additional columns will be automatically removed."
        )
        instructions.setWordWrap(True)
        info_layout.addWidget(instructions)
        
        info_group.setLayout(info_layout)
        
        # Create import area for file selection
        self.import_area = DropArea()
        self.import_area.fileDropped.connect(self.load_csv_file)
        
        # Add widgets to layout
        layout.addWidget(info_group)
        layout.addWidget(self.import_area)
        
        # Set layout for import tab
        import_tab.setLayout(layout)
        
        # Add to tabs
        self.tabs.addTab(import_tab, "Import")
    
    def test_drag_drop_system(self):
        """Diagnostic function to test if drag and drop handlers are working"""
        print("\n===== TESTING DRAG AND DROP SYSTEM =====")
        print("This will simulate a drop event with a test file path")
        
        # Create a test file
        test_file_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "test_file.csv")
        print(f"Test file path: {test_file_path}")
        
        try:
            # Create a simple CSV file for testing
            with open(test_file_path, 'w', newline='') as f:
                f.write("DATE,PLAYER,SOURCE,CHEST,SCORE\n")
                f.write("2024-03-16,TestPlayer,Test Source,Test Chest,100\n")
        except Exception as e:
            print(f"Error creating test file: {str(e)}")
            return
        
        # Direct load test
        print("\n=== BYPASSING DRAG AND DROP WITH DIRECT LOAD ===")
        print(f"Directly calling load_csv_file with path: {test_file_path}")
        self.load_csv_file(test_file_path)
        print("=== END OF DIRECT LOAD TEST ===\n")
        
        # Cleanup the test file
        try:
            os.remove(test_file_path)
        except Exception as e:
                        print(f"An error occurred: {e}")
        except:
            pass
            
        print("\nIf the direct load worked but drag and drop doesn't,")
        print("this confirms a system-level issue with Qt drag and drop.")
        print("===== END OF DRAG AND DROP TEST =====\n")
    
    def setup_raw_data_tab(self):
        """Setup the raw data tab UI"""
        raw_data_tab = QWidget()
        main_layout = QVBoxLayout()
        
        # Create a splitter for left/right division
        self.raw_data_splitter = QSplitter(Qt.Horizontal)
        
        # Create left side widget (filters + table)
        left_widget = QWidget()
        left_layout = QVBoxLayout()
        left_widget.setLayout(left_layout)
        
        # Create filter section
        filter_group = QGroupBox("Filter Data")
        filter_layout = QVBoxLayout()
        
        # Create horizontal layout for column filters
        column_filter_layout = QHBoxLayout()
        
        # Column selector
        self.column_selector = QComboBox()
        
        # Add widgets to column filter layout
        column_filter_layout.addWidget(QLabel("Column:"))
        column_filter_layout.addWidget(self.column_selector)
        
        # Checkbox to show/hide specific values selection
        self.show_value_selection = QCheckBox("Select specific values")
        self.show_value_selection.setChecked(False)
        self.show_value_selection.stateChanged.connect(self.toggle_value_selection)
        column_filter_layout.addWidget(self.show_value_selection)
        
        column_filter_layout.addStretch()
        
        # Add date range filter section
        date_filter_layout = QHBoxLayout()
        date_filter_layout.addWidget(QLabel("Date Range:"))
        
        # Start date picker
        self.start_date_edit = QDateEdit()
        self.start_date_edit.setCalendarPopup(True)
        self.start_date_edit.setDisplayFormat("yyyy-MM-dd")
        self.start_date_edit.setDate(QDate.currentDate().addDays(-30))  # Default to 30 days ago
        
        # End date picker
        self.end_date_edit = QDateEdit()
        self.end_date_edit.setCalendarPopup(True)
        self.end_date_edit.setDisplayFormat("yyyy-MM-dd")
        self.end_date_edit.setDate(QDate.currentDate())  # Default to today
        
        date_filter_layout.addWidget(self.start_date_edit)
        date_filter_layout.addWidget(QLabel("to"))
        date_filter_layout.addWidget(self.end_date_edit)
        
        # Date filter enabled checkbox
        self.date_filter_enabled = QCheckBox("Enable Date Filter")
        date_filter_layout.addWidget(self.date_filter_enabled)
        date_filter_layout.addStretch()
        
        # Buttons layout
        button_layout = QHBoxLayout()
        
        # Apply filter button
        self.apply_filter_button = QPushButton("Apply Filter")
        self.apply_filter_button.clicked.connect(self.filter_raw_data)
        
        # Clear filter button
        self.clear_filter_button = QPushButton("Clear Filter")
        self.clear_filter_button.clicked.connect(self.clear_filters)
        
        button_layout.addWidget(self.apply_filter_button)
        button_layout.addWidget(self.clear_filter_button)
        
        # Export button
        self.export_raw_data_button = QPushButton("Export to CSV")
        self.export_raw_data_button.clicked.connect(self.export_raw_data)
        button_layout.addWidget(self.export_raw_data_button)
        
        button_layout.addStretch()
        
        # Add all layouts to the filter layout
        filter_layout.addLayout(column_filter_layout)
        filter_layout.addLayout(date_filter_layout)
        filter_layout.addLayout(button_layout)
        
        filter_group.setLayout(filter_layout)
        
        # Create table view for raw data
        self.raw_data_table = QTableView()
        self.raw_data_table.setSortingEnabled(True)
        self.raw_data_table.horizontalHeader().setSectionResizeMode(QHeaderView.Interactive)
        self.raw_data_table.horizontalHeader().setMinimumSectionSize(80)
        self.raw_data_table.setAlternatingRowColors(True)
        
        # Connect column selection to update value options
        self.column_selector.currentIndexChanged.connect(self.update_filter_options)
        
        # Add widgets to left layout
        left_layout.addWidget(filter_group)
        left_layout.addWidget(self.raw_data_table)
        
        # Create right side widget (value selection)
        right_widget = QWidget()
        right_layout = QVBoxLayout()
        right_widget.setLayout(right_layout)
        
        # Value selection group
        value_group = QGroupBox("Value Selection")
        value_layout = QVBoxLayout()
        
        # Select/Deselect All buttons
        select_buttons_layout = QHBoxLayout()
        
        self.select_all_button = QPushButton("Select All")
        self.select_all_button.clicked.connect(self.select_all_values)
        
        self.deselect_all_button = QPushButton("Deselect All")
        self.deselect_all_button.clicked.connect(self.deselect_all_values)
        
        select_buttons_layout.addWidget(self.select_all_button)
        select_buttons_layout.addWidget(self.deselect_all_button)
        select_buttons_layout.addStretch()
        
        value_layout.addLayout(select_buttons_layout)
        
        # Create list widget for value selection
        self.value_list = QListWidget()
        self.value_list.setSelectionMode(QListWidget.MultiSelection)
        self.value_list.setMinimumHeight(100)
        
        value_layout.addWidget(QLabel("Values (select multiple):"))
        value_layout.addWidget(self.value_list)
        
        value_group.setLayout(value_layout)
        right_layout.addWidget(value_group)
        
        # Add left and right widgets to splitter
        self.raw_data_splitter.addWidget(left_widget)
        self.raw_data_splitter.addWidget(right_widget)
        
        # Set initial sizes (left side gets more space)
        self.raw_data_splitter.setSizes([700, 300])
        
        # Hide right side initially (will show when checkbox is checked)
        right_widget.hide()
        
        # Add splitter to main layout
        main_layout.addWidget(self.raw_data_splitter)
        
        # Set layout for raw data tab
        raw_data_tab.setLayout(main_layout)
        
        # Add to tabs
        self.tabs.addTab(raw_data_tab, "Raw Data")
    
    def setup_analysis_tab(self):
        """Setup the analysis tab UI"""
        analysis_tab = QWidget()
        main_layout = QVBoxLayout()
        
        # Create a splitter for left/right division (like in Raw Data tab)
        self.analysis_splitter = QSplitter(Qt.Horizontal)
        
        # Create left side widget (filters + table)
        left_widget = QWidget()
        left_layout = QVBoxLayout()
        left_widget.setLayout(left_layout)
        
        # Create analysis controls
        controls_group = QGroupBox("Analysis Controls")
        controls_layout = QVBoxLayout()
        
        # Analysis view selector
        view_layout = QHBoxLayout()
        view_layout.addWidget(QLabel("View:"))
        
        # Analysis selector with Player Overview as the first option
        self.analysis_selector = QComboBox()
        self.analysis_selector.addItems([
            "Player Overview",  # Now first in the list
            "Player Total Scores", 
            "Scores by Chest Type", 
            "Scores by Source",
            "Scores by Date",
            "Player Average Scores",
            "Chest Count by Player"
        ])
        self.analysis_selector.currentIndexChanged.connect(self.update_analysis_view)
        
        # Player Overview is now the first item (index 0), no need to set it explicitly
        # as ComboBox selects the first item by default
        
        view_layout.addWidget(self.analysis_selector)
        view_layout.addStretch()
        
        # Add filter section
        filter_layout = QHBoxLayout()
        
        # Column selector
        filter_layout.addWidget(QLabel("Filter Column:"))
        
        self.analysis_column_selector = QComboBox()
        filter_layout.addWidget(self.analysis_column_selector)
        
        # Checkbox to show/hide specific values selection
        self.analysis_show_value_selection = QCheckBox("Select specific values")
        self.analysis_show_value_selection.setChecked(False)
        self.analysis_show_value_selection.stateChanged.connect(self.toggle_analysis_value_selection)
        filter_layout.addWidget(self.analysis_show_value_selection)
        
        filter_layout.addStretch()
        
        # Add date range filter section
        date_filter_layout = QHBoxLayout()
        date_filter_layout.addWidget(QLabel("Date Range:"))
        
        # Start date picker
        self.analysis_start_date_edit = QDateEdit()
        self.analysis_start_date_edit.setCalendarPopup(True)
        self.analysis_start_date_edit.setDisplayFormat("yyyy-MM-dd")
        self.analysis_start_date_edit.setDate(QDate.currentDate().addDays(-30))  # Default to 30 days ago
        
        # End date picker
        self.analysis_end_date_edit = QDateEdit()
        self.analysis_end_date_edit.setCalendarPopup(True)
        self.analysis_end_date_edit.setDisplayFormat("yyyy-MM-dd")
        self.analysis_end_date_edit.setDate(QDate.currentDate())  # Default to today
        
        date_filter_layout.addWidget(self.analysis_start_date_edit)
        date_filter_layout.addWidget(QLabel("to"))
        date_filter_layout.addWidget(self.analysis_end_date_edit)
        
        # Date filter enabled checkbox
        self.analysis_date_filter_enabled = QCheckBox("Enable Date Filter")
        date_filter_layout.addWidget(self.analysis_date_filter_enabled)
        date_filter_layout.addStretch()
        
        # Buttons layout
        button_layout = QHBoxLayout()
        
        # Apply filter button
        self.analysis_apply_filter_button = QPushButton("Apply Filter")
        self.analysis_apply_filter_button.clicked.connect(self.filter_analysis_data)
        
        # Clear filter button
        self.analysis_clear_filter_button = QPushButton("Clear Filter")
        self.analysis_clear_filter_button.clicked.connect(self.clear_analysis_filters)
        
        button_layout.addWidget(self.analysis_apply_filter_button)
        button_layout.addWidget(self.analysis_clear_filter_button)
        
        # Export button
        self.analysis_export_button = QPushButton("Export Results")
        self.analysis_export_button.clicked.connect(self.export_current_analysis)
        button_layout.addWidget(self.analysis_export_button)
        
        button_layout.addStretch()
        
        # Add all layouts to controls layout
        controls_layout.addLayout(view_layout)
        controls_layout.addLayout(filter_layout)
        controls_layout.addLayout(date_filter_layout)
        controls_layout.addLayout(button_layout)
        
        controls_group.setLayout(controls_layout)
        
        # Create analysis view
        self.analysis_view = QTableView()
        self.analysis_view.setSortingEnabled(True)
        self.analysis_view.horizontalHeader().setSectionResizeMode(QHeaderView.Interactive)
        self.analysis_view.horizontalHeader().setMinimumSectionSize(100)
        self.analysis_view.setAlternatingRowColors(True)
        
        # Connect column selection to update value options
        self.analysis_column_selector.currentIndexChanged.connect(self.update_analysis_filter_options)
        
        # Add widgets to left layout
        left_layout.addWidget(controls_group)
        left_layout.addWidget(self.analysis_view)
        
        # Create right side widget (value selection)
        right_widget = QWidget()
        right_layout = QVBoxLayout()
        right_widget.setLayout(right_layout)
        
        # Value selection group
        value_group = QGroupBox("Value Selection")
        value_layout = QVBoxLayout()
        
        # Select/Deselect All buttons
        select_buttons_layout = QHBoxLayout()
        
        self.analysis_select_all_button = QPushButton("Select All")
        self.analysis_select_all_button.clicked.connect(self.select_all_analysis_values)
        
        self.analysis_deselect_all_button = QPushButton("Deselect All")
        self.analysis_deselect_all_button.clicked.connect(self.deselect_all_analysis_values)
        
        select_buttons_layout.addWidget(self.analysis_select_all_button)
        select_buttons_layout.addWidget(self.analysis_deselect_all_button)
        select_buttons_layout.addStretch()
        
        value_layout.addLayout(select_buttons_layout)
        
        # Create list widget for value selection
        self.analysis_value_list = QListWidget()
        self.analysis_value_list.setSelectionMode(QListWidget.MultiSelection)
        self.analysis_value_list.setMinimumHeight(100)
        
        value_layout.addWidget(QLabel("Values (select multiple):"))
        value_layout.addWidget(self.analysis_value_list)
        
        value_group.setLayout(value_layout)
        right_layout.addWidget(value_group)
        
        # Add left and right widgets to splitter
        self.analysis_splitter.addWidget(left_widget)
        self.analysis_splitter.addWidget(right_widget)
        
        # Set initial sizes (left side gets more space)
        self.analysis_splitter.setSizes([700, 300])
        
        # Hide right side initially (will show when checkbox is checked)
        right_widget.hide()
        
        # Add splitter to main layout
        main_layout.addWidget(self.analysis_splitter)
        
        # Set layout for analysis tab
        analysis_tab.setLayout(main_layout)
        
        # Add to tabs
        self.tabs.addTab(analysis_tab, "Analysis")
    
    def setup_charts_tab(self):
        """Setup the charts tab UI"""
        charts_tab = QWidget()
        main_layout = QVBoxLayout()
        
        # Create chart controls in a group
        controls_group = QGroupBox("Chart Controls")
        controls_layout = QGridLayout()
        
        # Row 1: Chart type and data selectors
        controls_layout.addWidget(QLabel("Chart Type:"), 0, 0)
        self.chart_type_selector = QComboBox()
        self.chart_type_selector.addItems([
            "Bar Chart", 
            "Pie Chart", 
            "Line Chart", 
            "Scatter Plot", 
            "Stacked Bar Chart",
            "Horizontal Bar Chart",
            "Bubble Chart",  # New chart type to visualize multiple dimensions
        ])
        controls_layout.addWidget(self.chart_type_selector, 0, 1)
        
        controls_layout.addWidget(QLabel("Data Column:"), 0, 2)
        self.chart_data_selector = QComboBox()
        self.chart_data_selector.addItems([
            "PLAYER", 
            "SOURCE", 
            "CHEST", 
            "DATE", 
            "TOTAL_SCORE",  # Important column we want to highlight 
            "CHEST_COUNT"   # Important column we want to highlight
        ])
        controls_layout.addWidget(self.chart_data_selector, 0, 3)
        
        # Row 2: Advanced options
        controls_layout.addWidget(QLabel("Chart Style:"), 1, 0)
        self.chart_style_selector = QComboBox()
        self.chart_style_selector.addItems(["Default", "Minimal", "Detailed"])
        self.chart_style_selector.currentTextChanged.connect(self.update_chart_style)
        controls_layout.addWidget(self.chart_style_selector, 1, 1)
        
        controls_layout.addWidget(QLabel("Top Items:"), 1, 2)
        self.chart_limit_selector = QComboBox()
        self.chart_limit_selector.addItems(["All", "Top 5", "Top 10", "Top 20"])
        controls_layout.addWidget(self.chart_limit_selector, 1, 3)
        
        # Row 3: Additional options
        controls_layout.addWidget(QLabel("Show Values:"), 2, 0)
        self.show_values_checkbox = QCheckBox()
        self.show_values_checkbox.setChecked(True)
        controls_layout.addWidget(self.show_values_checkbox, 2, 1)
        
        controls_layout.addWidget(QLabel("Sort By:"), 2, 2)
        self.sort_selector = QComboBox()
        self.sort_selector.addItems(["Value (Desc)", "Value (Asc)", "Name (A-Z)", "Name (Z-A)"])
        controls_layout.addWidget(self.sort_selector, 2, 3)
        
        # Action buttons row
        button_layout = QHBoxLayout()
        
        # Update chart button
        self.update_chart_button = QPushButton("Update Chart")
        self.update_chart_button.clicked.connect(self.update_chart)
        button_layout.addWidget(self.update_chart_button)
        
        # Export chart button
        self.export_chart_button = QPushButton("Export Chart")
        self.export_chart_button.clicked.connect(self.export_chart)
        button_layout.addWidget(self.export_chart_button)
        
        # Add button layout to controls
        controls_layout.addLayout(button_layout, 3, 0, 1, 4)
        
        controls_group.setLayout(controls_layout)
        
        # Create matplotlib canvas
        self.mpl_canvas = MplCanvas(self, width=8, height=6, dpi=100)
        
        # Add widgets to main layout
        main_layout.addWidget(controls_group)
        main_layout.addWidget(self.mpl_canvas, 1)  # Stretch factor 1 to expand with window
        
        # Set layout for charts tab
        charts_tab.setLayout(main_layout)
        
        # Add to tabs
        self.tabs.addTab(charts_tab, "Charts")
    
    def setup_report_tab(self):
        """Setup the report tab UI with comprehensive reporting capabilities"""
        report_tab = QWidget()
        main_layout = QVBoxLayout()
        
        # Create report controls in a group
        controls_group = QGroupBox("Report Controls")
        controls_layout = QGridLayout()
        
        # Row 1: Report type selector
        controls_layout.addWidget(QLabel("Report Type:"), 0, 0)
        self.report_type_selector = QComboBox()
        self.report_type_selector.addItems([
            "Full Report",
            "Player Performance",
            "Chest Type Analysis",
            "Source Analysis"
        ])
        controls_layout.addWidget(self.report_type_selector, 0, 1)
        
        # Row 2: Include options
        controls_layout.addWidget(QLabel("Include:"), 1, 0)
        
        include_layout = QHBoxLayout()
        
        self.include_charts_checkbox = QCheckBox("Charts")
        self.include_charts_checkbox.setChecked(True)
        include_layout.addWidget(self.include_charts_checkbox)
        
        self.include_tables_checkbox = QCheckBox("Tables")
        self.include_tables_checkbox.setChecked(True)
        include_layout.addWidget(self.include_tables_checkbox)
        
        self.include_stats_checkbox = QCheckBox("Statistics")
        self.include_stats_checkbox.setChecked(True)
        include_layout.addWidget(self.include_stats_checkbox)
        
        include_layout.addStretch()
        controls_layout.addLayout(include_layout, 1, 1)
        
        # Action buttons row
        button_layout = QHBoxLayout()
        
        # Generate report button
        self.generate_report_button = QPushButton("Generate Report")
        self.generate_report_button.clicked.connect(self.generate_report)
        button_layout.addWidget(self.generate_report_button)
        
        # Export report button
        self.export_report_button = QPushButton("Export Report")
        self.export_report_button.clicked.connect(self.export_report)
        button_layout.addWidget(self.export_report_button)
        
        # Add button layout to controls
        controls_layout.addLayout(button_layout, 2, 0, 1, 2)
        
        controls_group.setLayout(controls_layout)
        
        # Create report view
        self.report_view = QTextBrowser()
        self.report_view.setOpenExternalLinks(True)
        self.report_view.setStyleSheet(f"""
            QTextBrowser {{
                background-color: {DARK_THEME['background_light']};
                color: {DARK_THEME['foreground']};
                border: 1px solid {DARK_THEME['border']};
                padding: 10px;
            }}
        """)
        
        # Add widgets to main layout
        main_layout.addWidget(controls_group)
        main_layout.addWidget(self.report_view, 1)  # Stretch factor 1 to expand with window
        
        # Set layout for report tab
        report_tab.setLayout(main_layout)
        
        # Add to tabs
        self.tabs.addTab(report_tab, "Report")
    
    def update_raw_data_view(self):
        """Update the raw data table view with current data"""
        if self.raw_data is None or self.raw_data.empty:
            return
            
        # Prepare data for table model
        headers = self.raw_data.columns.tolist()
        data = [row.tolist() for _, row in self.raw_data.iterrows()]
        
        # Create or update table model
        if not hasattr(self, 'raw_data_model') or self.raw_data_model is None:
            print("Creating new raw data model")
            # Create new model
            self.raw_data_model = CustomTableModel(data, headers)
        
            # Create proxy model for filtering
            self.raw_data_proxy_model = QSortFilterProxyModel()
            self.raw_data_proxy_model.setSourceModel(self.raw_data_model)
        
            # Set the model on the table view
            self.raw_data_table.setModel(self.raw_data_proxy_model)
        else:
            print("Updating existing raw data model")
            # Update existing model data
            self.raw_data_model.setData(data, headers)
        
        # Enable sorting
        self.raw_data_table.setSortingEnabled(True)
        
        # Set column widths
        for i in range(len(headers)):
            self.raw_data_table.setColumnWidth(i, 150)
            
        # Update filter options
        if hasattr(self, 'column_selector'):
            # Store the current selection
            current_selection = self.column_selector.currentText() if self.column_selector.count() > 0 else ""
            
            # Clear and repopulate
            self.column_selector.clear()
            self.column_selector.addItems(headers)
            
            # Restore selection if possible
            if current_selection:
                index = self.column_selector.findText(current_selection)
                if index >= 0:
                    self.column_selector.setCurrentIndex(index)
            
            # Make sure the value selection panel is hidden by default
            if hasattr(self, 'show_value_selection'):
                self.show_value_selection.setChecked(False)
                
                # Make sure the right widget is hidden
                right_widget = self.raw_data_splitter.widget(1)
                if right_widget:
                    right_widget.hide()
            
            # Update filter options for the selected column - this will select all values by default
            self.update_filter_options()
    
    def analyze_data(self):
        """
        Analyze the loaded CSV data and update various data views and statistics.
        This is the main method that processes the data after loading and prepares it for display
        in the different tabs of the application.
        """
        try:
            if not hasattr(self, 'raw_data') or self.raw_data is None or self.raw_data.empty:
                self.statusBar().showMessage("No data to analyze", 5000)
                return
                
            import pandas as pd
            
            print("Creating initial analysis_results structure")
            # Initialize analysis_results with empty DataFrames to prevent crashes
            self.analysis_results = {
                'player_totals': pd.DataFrame(columns=['PLAYER', 'TOTAL_SCORE']),
                'chest_totals': pd.DataFrame(columns=['CHEST', 'TOTAL_SCORE']),
                'source_totals': pd.DataFrame(columns=['SOURCE', 'TOTAL_SCORE']),
                'date_totals': pd.DataFrame(columns=['DATE', 'TOTAL_SCORE']),
                'player_avg': pd.DataFrame(columns=['PLAYER', 'AVG_SCORE']),
                'player_counts': pd.DataFrame(columns=['PLAYER', 'CHEST_COUNT']),
                'player_overview': pd.DataFrame(columns=['PLAYER', 'TOTAL_SCORE', 'CHEST_COUNT']),
            }
            
            # Process data for different tabs
            self.analyze_chests_data()
            
            # Make sure the analysis view is updated with the newly analyzed data
            print("Analysis complete, updating analysis view with the results")
            self.update_analysis_view()
                
            # Update the status bar
            self.statusBar().showMessage("Analysis complete", 5000)
        except Exception as e:
            print(f"Error analyzing data: {str(e)}")
            import traceback
            traceback.print_exc()
            self.statusBar().showMessage(f"Error in analysis: {str(e)}", 5000)
    
    def analyze_chests_data(self):
        """
        Analyze chest-specific data from the loaded CSV.
        This method processes chest opening data to extract statistics such as
        chest types, rewards, and probabilities for display in the Chests tab.
        """
        try:
            if not hasattr(self, 'raw_data') or self.raw_data is None or self.raw_data.empty:
                print("No data available for chest analysis")
                return
                
            print("Analyzing chest data...")
            
            # Make sure pandas is imported
            import pandas as pd
            
            # Perform actual analysis to populate self.analysis_results
            try:
                # Calculate player total scores - sum of scores per player
                self.analysis_results['player_totals'] = self.raw_data.groupby('PLAYER')['SCORE'].sum().reset_index()
                self.analysis_results['player_totals'].columns = ['PLAYER', 'TOTAL_SCORE']
                
                # Calculate chest type totals - sum of scores per chest type
                self.analysis_results['chest_totals'] = self.raw_data.groupby('CHEST')['SCORE'].sum().reset_index()
                self.analysis_results['chest_totals'].columns = ['CHEST', 'TOTAL_SCORE']
                
                # Calculate source totals - sum of scores per source
                self.analysis_results['source_totals'] = self.raw_data.groupby('SOURCE')['SCORE'].sum().reset_index()
                self.analysis_results['source_totals'].columns = ['SOURCE', 'TOTAL_SCORE']
                
                # Calculate date totals - sum of scores per date
                self.analysis_results['date_totals'] = self.raw_data.groupby('DATE')['SCORE'].sum().reset_index()
                self.analysis_results['date_totals'].columns = ['DATE', 'TOTAL_SCORE']
                
                # Calculate player average scores
                self.analysis_results['player_avg'] = self.raw_data.groupby('PLAYER')['SCORE'].mean().reset_index()
                self.analysis_results['player_avg'].columns = ['PLAYER', 'AVG_SCORE']
                
                # Calculate chest counts per player
                self.analysis_results['player_counts'] = self.raw_data.groupby('PLAYER').size().reset_index()
                self.analysis_results['player_counts'].columns = ['PLAYER', 'CHEST_COUNT']
                
                # Create player overview - combines totals, counts, and source/chest breakdowns
                player_totals = self.raw_data.groupby('PLAYER')['SCORE'].sum().reset_index()
                player_counts = self.raw_data.groupby('PLAYER').size().reset_index(name='CHEST_COUNT')
                
                # Add source breakdown only (no chest breakdown)
                source_breakdown = self.raw_data.pivot_table(
                    index='PLAYER', 
                    columns='SOURCE', 
                    values='SCORE', 
                    aggfunc='sum',
                    fill_value=0
                ).reset_index()
                
                # We'll use the original source names without any prefix
                # No renaming of columns needed, they're already good
                
                # Merge just player totals, counts, and source breakdown
                result = pd.merge(player_totals, player_counts, on='PLAYER')
                result = pd.merge(result, source_breakdown, on='PLAYER')
                
                # Sort by TOTAL_SCORE in descending order by default
                result = result.sort_values('TOTAL_SCORE', ascending=False)
                
                # Put the merged dataframe into the analysis_results
                self.analysis_results['player_overview'] = result
                
                print(f"Analysis complete: created {len(self.analysis_results)} result dataframes")
                for key, df in self.analysis_results.items():
                    print(f"  - {key}: {len(df)} rows, columns: {list(df.columns)}")
                
            except Exception as e:
                print(f"Error in data aggregation: {str(e)}")
                import traceback
                traceback.print_exc()
            
            print(f"Chest analysis complete. Dataset has {len(self.raw_data)} rows.")
            
        except Exception as e:
            print(f"Error in chest analysis: {str(e)}")
            import traceback
            traceback.print_exc()
    
    def update_analysis_view(self):
        """
        Update the analysis view table with the current analysis results.
        
        This method:
        1. Gets the currently selected view from the dropdown
        2. Retrieves the appropriate DataFrame from analysis_results
        3. Creates and sets up a table model with the data
        4. Configures the table view (column widths, sorting, etc.)
        5. Handles errors and edge cases (missing data, etc.)
        """
        print("\n=== Starting update_analysis_view ===")
        
        try:
            # Check if we have analysis results
            if not hasattr(self, 'analysis_results') or self.analysis_results is None:
                print("No analysis_results available, skipping update_analysis_view")
                return
                
            print("Getting selected view from analysis_selector")
            if not hasattr(self, 'analysis_selector'):
                print("analysis_selector not found, skipping update_analysis_view")
                return
            
            selected_view = self.analysis_selector.currentText()
            print(f"Selected view: {selected_view}")
        
            # Get the appropriate DataFrame based on the selected view
            try:
                if selected_view == "Player Total Scores":
                    df = self.analysis_results['player_totals']
                elif selected_view == "Scores by Chest Type":
                    df = self.analysis_results['chest_totals']
                elif selected_view == "Scores by Source":
                    df = self.analysis_results['source_totals']
                elif selected_view == "Scores by Date":
                    df = self.analysis_results['date_totals']
                elif selected_view == "Player Average Scores":
                    df = self.analysis_results['player_avg']
                elif selected_view == "Chest Count by Player":
                    df = self.analysis_results['player_counts']
                elif selected_view == "Player Overview":
                    df = self.analysis_results['player_overview']
                else:
                    print(f"Unknown view: {selected_view}, skipping update_analysis_view")
                    return
                
                print(f"Got DataFrame for '{selected_view}' with shape {df.shape}")
            except KeyError as e:
                print(f"KeyError accessing analysis_results with key '{selected_view}': {e}")
                print(f"Available keys: {list(self.analysis_results.keys())}")
                return
            except Exception as e:
                print(f"Error getting DataFrame for view '{selected_view}': {e}")
                import traceback
                traceback.print_exc()
                return
            
            # Prepare data for table model
            try:
                print("Preparing data for table model")
                headers = df.columns.tolist()
                print(f"Headers: {headers}")
                data = [row.tolist() for _, row in df.iterrows()]
                print(f"Data prepared with {len(data)} rows")
            except Exception as e:
                print(f"Error preparing data for table model: {e}")
                import traceback
                traceback.print_exc()
                return
        
            # Create and set up model
            try:
                print("Creating CustomTableModel")
                model = CustomTableModel(data, headers)
        
                print("Checking if analysis_view exists")
                if not hasattr(self, 'analysis_view'):
                    print("analysis_view not found, skipping model setup")
                    return

                print("Setting model on table view")
                self.analysis_view.setModel(model)
                self.analysis_view.setVisible(True)  # Ensure the view is visible
        
                # Set column widths
                print("Setting column widths")
                for i in range(len(headers)):
                    self.analysis_view.setColumnWidth(i, 150)
                
                # Store this model for future reference
                print("Storing current analysis model")
                self.current_analysis_model = model
                
                # Make sure the parent widget is visible
                if self.analysis_view.parent():
                    print("Making sure parent widgets are visible")
                    self.analysis_view.parent().setVisible(True)
                
                # If this method was triggered by a user changing the view dropdown
                if self.sender() == self.analysis_selector:
                    print("View was changed by user, applying filter to ensure table updates")
                    # Apply filter to ensure data is displayed correctly
                    self.filter_analysis_data()
                
                # Make sure the Analysis tab is selected if we're in an automated context
                # Only do this during programmatic calls, not user-driven ones
                if hasattr(self, 'tabs') and not self.sender():
                    print("Checking current tab")
                    current_tab = self.tabs.currentIndex()
                    analysis_tab_index = 2  # Typically the Analysis tab is at index 2
                    
                    # Find actual Analysis tab index by name
                    for i in range(self.tabs.count()):
                        if self.tabs.tabText(i) == "Analysis":
                            analysis_tab_index = i
                            break
                    
                    print(f"Current tab index: {current_tab}, Analysis tab index: {analysis_tab_index}")
                    if current_tab != analysis_tab_index:
                        print(f"Setting current tab to Analysis (index {analysis_tab_index})")
                        self.tabs.setCurrentIndex(analysis_tab_index)
                
                print("Table model set up successfully")
            except Exception as e:
                print(f"Error setting up table model: {e}")
                import traceback
                traceback.print_exc()
                return
                
            # Update the analysis column selector with available columns
            try:
                print("Updating analysis column selector")
                if hasattr(self, 'analysis_column_selector'):
                    # Store the current selection
                    current_selection = self.analysis_column_selector.currentText() if self.analysis_column_selector.count() > 0 else ""
                    print(f"Current selection: '{current_selection}'")
                    
                    # Clear and repopulate with columns that are available for filtering
                    self.analysis_column_selector.clear()
                    
                    # Get columns from the raw data for filtering
                    if self.raw_data is not None and not self.raw_data.empty:
                        columns = self.raw_data.columns.tolist()
                        print(f"Adding {len(columns)} columns to analysis_column_selector")
                        self.analysis_column_selector.addItems(columns)
                    else:
                        print("No raw_data available for column selection")
                    
                    # Restore selection if possible
                    if current_selection:
                        index = self.analysis_column_selector.findText(current_selection)
                        print(f"Restoring selection '{current_selection}', found at index {index}")
                        if index >= 0:
                            self.analysis_column_selector.setCurrentIndex(index)
                else:
                    print("analysis_column_selector not found")
            except Exception as e:
                print(f"Error updating analysis column selector: {e}")
                import traceback
                traceback.print_exc()
                # Continue execution, as this is not critical
                
            # Handle analysis value selection panel
            try:
                print("Handling analysis value selection panel")
                if hasattr(self, 'analysis_show_value_selection') and not self.analysis_show_value_selection.isChecked():
                    print("Value selection panel should be hidden")
                    # If the selection panel is not visible, keep it hidden
                    if hasattr(self, 'analysis_splitter'):
                        right_widget = self.analysis_splitter.widget(1)
                        if right_widget:
                            print("Hiding right widget")
                            right_widget.hide()
                        else:
                            print("Right widget of analysis_splitter not found")
                    else:
                        print("analysis_splitter not found")
                elif hasattr(self, 'analysis_show_value_selection') and self.analysis_show_value_selection.isChecked():
                    print("Value selection panel should be visible, updating filter options")
                    # If it's visible, update the filter options
                    self.update_analysis_filter_options()
                else:
                    print("analysis_show_value_selection not found or in indeterminate state")
            except Exception as e:
                print(f"Error handling analysis value selection panel: {e}")
                import traceback
                traceback.print_exc()
                # Continue execution, as this is not critical
                
            print("=== update_analysis_view completed successfully ===\n")
            
        except Exception as e:
            print(f"Unhandled error in update_analysis_view: {e}")
            import traceback
            traceback.print_exc()
    
    def update_chart(self):
        """
        Update the chart based on current selections.
        
        This method handles:
        1. Getting the chart type and data selections
        2. Determining which analysis view to use
        3. Setting the appropriate y-column based on the view
        4. Applying sorting and data limiting
        5. Creating the appropriate chart type
        6. Setting chart styling and labels
        7. Error handling for chart creation
        """
        print("\n=== Starting update_chart ===")
        
        if self.analysis_results is None or not self.analysis_results:
            print("No analysis results available")
            return
            
        # Get selected parameters
        chart_type = self.chart_type_selector.currentText()
        x_column = self.chart_data_selector.currentText()
        
        # Get current view - we'll keep Player Overview selected if it's already selected
        current_view = self.analysis_selector.currentText()
        
        # Auto-select the appropriate view based on x_column
        if x_column == "PLAYER":
            # If the current view is Player Overview, keep it, otherwise use Player Total Scores
            if current_view == "Player Overview":
                selected_view = "Player Overview"
            else:
                selected_view = "Player Total Scores"
        elif x_column == "CHEST":
            selected_view = "Scores by Chest Type"
        elif x_column == "SOURCE":
            selected_view = "Scores by Source"
        elif x_column == "DATE":
            selected_view = "Scores by Date"
        elif x_column == "PLAYER_AVG":
            selected_view = "Player Average Scores"
        elif x_column == "CHEST_COUNT":
            selected_view = "Chest Count by Player"
        else:
            selected_view = self.analysis_selector.currentText()
            
        # Update the analysis selector to match our selection
        index = self.analysis_selector.findText(selected_view)
        if index >= 0:
            self.analysis_selector.setCurrentIndex(index)
            
        print(f"Chart parameters: type={chart_type}, x={x_column}, view={selected_view}")
        
        try:
            # Clear previous chart
            self.mpl_canvas.axes.clear()
            
            # Get the appropriate DataFrame based on selected view
            print(f"Available analysis results keys: {list(self.analysis_results.keys())}")
            
            if selected_view == "Player Total Scores":
                data = self.analysis_results['player_totals']
            elif selected_view == "Scores by Chest Type":
                data = self.analysis_results['chest_totals']
            elif selected_view == "Scores by Source":
                data = self.analysis_results['source_totals']
            elif selected_view == "Scores by Date":
                data = self.analysis_results['date_totals']
            elif selected_view == "Player Average Scores":
                data = self.analysis_results['player_avg']
            elif selected_view == "Chest Count by Player":
                data = self.analysis_results['player_counts']
            elif selected_view == "Player Overview":
                data = self.analysis_results['player_overview']
            else:
                print(f"Unknown view selection: {selected_view}")
                QMessageBox.warning(self, "Chart Error", f"Unknown view: {selected_view}")
                return
            
            # Debug: print DataFrame info
            print(f"DataFrame shape: {data.shape}")
            print(f"DataFrame columns: {data.columns.tolist()}")
            print(f"DataFrame sample:\n{data.head(3)}")
            
            # Check if the selected columns exist in the DataFrame
            if x_column not in data.columns:
                print(f"Error: x_column '{x_column}' not found in DataFrame columns")
                QMessageBox.warning(self, "Chart Error", f"Column '{x_column}' not found in the data")
                return
            
            # Make a copy to avoid modifying the original
            data = data.copy()
            
            # Set the appropriate y-column based on the selected view
            if selected_view == "Player Overview":
                # Player Overview uses different column names
                if 'TOTAL_SCORE' in data.columns:
                    y_column_actual = 'TOTAL_SCORE'
                elif 'CHEST_COUNT' in data.columns:
                    y_column_actual = 'CHEST_COUNT'
                else:
                    print("Neither TOTAL_SCORE nor CHEST_COUNT found in Player Overview data")
                    y_column_actual = data.columns[1] if len(data.columns) > 1 else data.columns[0]
            else:
                # Other views use SCORE or COUNT
                if 'SCORE' in data.columns:
                    y_column_actual = 'SCORE'
                elif 'COUNT' in data.columns:
                    y_column_actual = 'COUNT'
                else:
                    print("Neither SCORE nor COUNT found in data")
                    y_column_actual = data.columns[1] if len(data.columns) > 1 else data.columns[0]
            
            print(f"Using y_column_actual: {y_column_actual}")
            
            # Apply sorting if the sort selector exists
            if hasattr(self, 'sort_selector') and self.sort_selector.count() > 0:
                sort_option = self.sort_selector.currentText()
                if sort_option == "Value (Desc)":
                    data = data.sort_values(y_column_actual, ascending=False)
                elif sort_option == "Value (Asc)":
                    data = data.sort_values(y_column_actual, ascending=True)
                elif sort_option == "Name (A-Z)":
                    data = data.sort_values(x_column, ascending=True)
                elif sort_option == "Name (Z-A)":
                    data = data.sort_values(x_column, ascending=False)
            else:
                # Default sort by value descending
                if y_column_actual in data.columns:
                    data = data.sort_values(y_column_actual, ascending=False)
                
            # Apply data limiting if the limit selector exists
            if hasattr(self, 'chart_limit_selector') and self.chart_limit_selector.count() > 0:
                limit_option = self.chart_limit_selector.currentText()
                if limit_option != "All":
                    limit = int(limit_option.split()[1])  # Extract number from "Top X"
                    if len(data) > limit:
                        print(f"Limiting chart to {limit_option} entries (total: {len(data)})")
                        if hasattr(self, 'sort_selector') and self.sort_selector.count() > 0:
                            sort_option = self.sort_selector.currentText()
                            if sort_option == "Value (Asc)" or sort_option == "Name (A-Z)":
                                # For ascending sorts, take the last N items
                                data = data.iloc[-limit:]
                            else:
                                # For descending sorts, take the first N items
                                data = data.head(limit)
                        else:
                            # Default to taking the top N by value
                            data = data.head(limit)
            
            # Decide whether to show values based on checkbox if it exists
            show_values = True  # Default
            if hasattr(self, 'show_values_checkbox'):
                show_values = self.show_values_checkbox.isChecked()
            
            print(f"Creating {chart_type} with x={x_column}, y={y_column_actual}")
            
            # Handle different chart types
            if chart_type == "Bar Chart":
                print("Generating bar chart...")
                
                bars = data.plot(
                    kind='bar', 
                    x=x_column, 
                    y=y_column_actual, 
                    ax=self.mpl_canvas.axes,
                    color=self.mpl_canvas.chart_colors[0],
                    edgecolor=DARK_THEME['border'],
                    width=0.7
                )
                
                # Add value labels on top of bars if requested
                if show_values:
                    for bar in bars.patches:
                        height = bar.get_height()
                        self.mpl_canvas.axes.text(
                            bar.get_x() + bar.get_width()/2.,
                            height + 0.02 * (data[y_column_actual].max() or 1),
                            f'{height:,.0f}',
                            ha='center', 
                            va='bottom',
                            color=DARK_THEME['foreground'],
                            fontsize=9
                        )
                
            elif chart_type == "Horizontal Bar Chart":
                print(f"Creating Horizontal Bar Chart with x={x_column}, y={y_column_actual}")
                print("Generating horizontal bar chart...")
                
                # Use direct matplotlib for horizontal bar charts
                y_pos = np.arange(len(data))
                labels = data[x_column].tolist()
                values = data[y_column_actual].tolist()
                
                # Create the horizontal bar chart
                bars = self.mpl_canvas.axes.barh(y_pos, values, color=DARK_THEME['accent'], alpha=0.8)
                
                # Set x and y labels (note the swap for horizontal)
                self.mpl_canvas.axes.set_yticks(y_pos)
                self.mpl_canvas.axes.set_yticklabels(labels)
                
                # Show values on bars if requested
                if show_values:
                    for i, v in enumerate(values):
                        self.mpl_canvas.axes.text(
                            v + 0.1, i, f"{v:.0f}", 
                            va='center', color=DARK_THEME['foreground']
                        )
            
            elif chart_type == "Line Chart":
                print("Generating line chart...")
                
                data.plot(
                    kind='line', 
                    x=x_column, 
                    y=y_column_actual, 
                    ax=self.mpl_canvas.axes,
                    color=self.mpl_canvas.chart_colors[0],
                    marker='o',
                    markersize=5,
                    linewidth=2
                )
                
                # Add value labels if requested
                if show_values:
                    for i, (x, y) in enumerate(zip(data[x_column], data[y_column_actual])):
                        self.mpl_canvas.axes.text(
                            i, 
                            y + 0.02 * (data[y_column_actual].max() or 1),
                            f'{y:,.0f}',
                            ha='center',
                            va='bottom',
                            color=DARK_THEME['foreground'],
                            fontsize=9
                        )
            
            elif chart_type == "Pie Chart":
                print("Generating pie chart...")
                
                # For pie charts, we use the current value column
                value_column = y_column_actual
                
                # Create a series for the pie chart
                pie_data = pd.Series(
                    data[value_column].values, 
                    index=data[x_column].values
                )
                
                wedges, texts, autotexts = self.mpl_canvas.axes.pie(
                    pie_data,
                    labels=None,  # We'll add a legend instead
                    autopct='%1.1f%%' if show_values else '',
                    shadow=False,
                    startangle=90,
                    colors=self.mpl_canvas.chart_colors
                )
                
                # Enhance the appearance of percentage labels
                if show_values:
                    for autotext in autotexts:
                        autotext.set_color('white')
                        autotext.set_fontsize(9)
                        autotext.set_weight('bold')
                
                # Add a legend
                self.mpl_canvas.axes.legend(
                    wedges, 
                    pie_data.index,
                    title=x_column,
                    loc="center left",
                    bbox_to_anchor=(1, 0, 0.5, 1)
                )
                
                self.mpl_canvas.axes.axis('equal')  # Equal aspect ratio ensures the pie is circular
            
            elif chart_type == "Scatter Plot":
                print("Generating scatter plot...")
                
                # For Player Overview, we might want to plot TOTAL_SCORE vs CHEST_COUNT
                if selected_view == "Player Overview" and 'CHEST_COUNT' in data.columns and 'TOTAL_SCORE' in data.columns:
                    scatter = self.mpl_canvas.axes.scatter(
                        data['CHEST_COUNT'], 
                        data['TOTAL_SCORE'],
                        s=50,  # Marker size
                        c=np.arange(len(data)),  # Color based on index
                        cmap='YlOrBr',  # Yellow to Orange to Brown colormap
                        alpha=0.8,
                        edgecolors=DARK_THEME['border']
                    )
                    
                    # Add player names as annotations if requested
                    if show_values:
                        for i, player in enumerate(data['PLAYER']):
                            self.mpl_canvas.axes.annotate(
                                player,
                                (data['CHEST_COUNT'].iloc[i], data['TOTAL_SCORE'].iloc[i]),
                                xytext=(5, 5),
                                textcoords='offset points',
                                fontsize=8,
                                color=DARK_THEME['foreground']
                            )
                    
                    # Set axis labels for this special case
                    self.mpl_canvas.axes.set_xlabel('Chest Count', color=DARK_THEME['foreground'])
                    self.mpl_canvas.axes.set_ylabel('Total Score', color=DARK_THEME['foreground'])
                    
                else:
                    # Default scatter plot using x_column and y_column_actual
                    scatter = self.mpl_canvas.axes.scatter(
                        np.arange(len(data)),  # Use index for x-axis
                        data[y_column_actual],
                        s=50,  # Marker size
                        c=data[y_column_actual],  # Color based on value
                        cmap='YlOrBr',  # Yellow to Orange to Brown colormap
                        alpha=0.8,
                        edgecolors=DARK_THEME['border']
                    )
                    
                    # Add labels if requested
                    if show_values:
                        for i, txt in enumerate(data[x_column]):
                            self.mpl_canvas.axes.annotate(
                                txt,
                                (i, data[y_column_actual].iloc[i]),
                                xytext=(5, 5),
                                textcoords='offset points',
                                fontsize=8,
                                color=DARK_THEME['foreground']
                            )
                    
                    # Add colorbar
                    plt.colorbar(scatter, ax=self.mpl_canvas.axes)
            
            elif chart_type == "Stacked Bar Chart":
                print("Generating stacked bar chart...")
                
                # Stacked bar charts work well with Player Overview data
                if selected_view == "Player Overview":
                    # Get source columns (exclude the standard non-source columns)
                    source_columns = [col for col in data.columns 
                                    if col not in ['PLAYER', 'TOTAL_SCORE', 'CHEST_COUNT']]
                    
                    print(f"Available source columns: {source_columns}")
                    
                    # Check if we have any source columns to stack
                    if not source_columns:
                        # No source columns found, create a single-column bar chart instead
                        print("No columns available for stacking, creating regular bar chart")
                        bars = data.plot(
                            kind='bar', 
                            x='PLAYER', 
                            y='TOTAL_SCORE', 
                            ax=self.mpl_canvas.axes,
                            color=self.mpl_canvas.chart_colors[0],
                            edgecolor=DARK_THEME['border'],
                            width=0.7
                        )
                        
                        # Add value labels if requested
                        if show_values:
                            for bar in bars.patches:
                                height = bar.get_height()
                                self.mpl_canvas.axes.text(
                                    bar.get_x() + bar.get_width()/2.,
                                    height + 0.02 * (data['TOTAL_SCORE'].max() or 1),
                                    f'{height:,.0f}',
                                    ha='center', 
                                    va='bottom',
                                    color=DARK_THEME['foreground'],
                                    fontsize=9
                                )
                        
                        self.statusBar().showMessage(
                            "No source scores available for stacking. Using regular bar chart.", 
                            5000
                        )
                    else:
                        # Limit to top source types if too many columns (plot clarity)
                        if len(source_columns) > 10:
                            # Sum values across all players for each source type
                            source_totals = data[source_columns].sum().sort_values(ascending=False)
                            top_sources = source_totals.head(10).index.tolist()
                            # Keep top sources and add an "Other" category
                            plot_data = data[['PLAYER'] + top_sources].copy()
                            plot_data['Other'] = data[source_columns].drop(columns=top_sources).sum(axis=1)
                            source_columns = top_sources + ['Other']
                        else:
                            plot_data = data[['PLAYER'] + source_columns].copy()
                        
                        print(f"Creating stacked bar chart with columns: {list(plot_data.columns)}")
                        print(f"Numeric columns: {plot_data.select_dtypes(include=['number']).columns.tolist()}")
                        
                        try:
                            # Create a stacked bar chart
                            plot_data.set_index('PLAYER').plot(
                                kind='bar',
                                stacked=True,
                                ax=self.mpl_canvas.axes,
                                colormap='YlOrBr',
                                edgecolor=DARK_THEME['border'],
                                width=0.8
                            )
                            
                            # Set legend title to 'Source'
                            if self.mpl_canvas.axes.get_legend():
                                self.mpl_canvas.axes.get_legend().set_title('Source')
                                
                        except Exception as e:
                            print(f"Error creating stacked bar chart: {str(e)}")
                            import traceback
                            traceback.print_exc()
                            
                            # Fallback to regular bar chart
                            bars = data.plot(
                                kind='bar', 
                                x='PLAYER', 
                                y='TOTAL_SCORE', 
                                ax=self.mpl_canvas.axes,
                                color=self.mpl_canvas.chart_colors[0],
                                edgecolor=DARK_THEME['border'],
                                width=0.7
                            )
                            
                            self.statusBar().showMessage(
                                f"Could not create stacked chart: {str(e)}. Using regular bar chart.", 
                                5000
                            )
                else:
                    # For other views, we might not have multiple categories to stack
                    # Just create a regular bar chart
                    bars = data.plot(
                        kind='bar', 
                        x=x_column, 
                        y=y_column_actual, 
                        ax=self.mpl_canvas.axes,
                        color=self.mpl_canvas.chart_colors[0],
                        edgecolor=DARK_THEME['border'],
                        width=0.7
                    )
                    
                    # Show a message that stacked charts work best with Player Overview
                    self.statusBar().showMessage(
                        "Stacked charts work best with 'Player Overview' view", 
                        5000
                    )
            
            # Set chart title and labels
            view_title = selected_view.replace(" by ", "\nby ")
            self.mpl_canvas.axes.set_title(view_title, color=DARK_THEME['foreground'], fontsize=14)
            
            if chart_type != "Pie Chart" and chart_type != "Scatter Plot" and not (chart_type == "Stacked Bar Chart" and selected_view == "Player Overview"):
                self.mpl_canvas.axes.set_xlabel(x_column, color=DARK_THEME['foreground'])
                
                # Set y label based on the view
                if "Count" in selected_view:
                    self.mpl_canvas.axes.set_ylabel("Count", color=DARK_THEME['foreground'])
                else:
                    self.mpl_canvas.axes.set_ylabel("Score", color=DARK_THEME['foreground'])
                
                # Add grid based on current style if style_presets exist
                if hasattr(self.mpl_canvas, 'style_presets') and hasattr(self.mpl_canvas, 'current_style'):
                    style = self.mpl_canvas.style_presets[self.mpl_canvas.current_style]
                    self.mpl_canvas.axes.grid(
                        style.get('grid', True), 
                        linestyle=style.get('grid_linestyle', '--'), 
                        alpha=style.get('grid_alpha', 0.7)
                    )
                else:
                    # Default grid settings
                    self.mpl_canvas.axes.grid(True, linestyle='--', alpha=0.7)
                
                # Rotate x tick labels if we have more than a few items
                if len(data) > 5 and chart_type != "Horizontal Bar Chart":
                    self.mpl_canvas.axes.tick_params(axis='x', labelrotation=45)
            
            # Apply the current style if style_selector exists
            if hasattr(self, 'chart_style_selector') and self.chart_style_selector.count() > 0:
                style_name = self.chart_style_selector.currentText().lower()
                if hasattr(self.mpl_canvas, 'apply_style'):
                    self.mpl_canvas.apply_style(style_name)
            
            # Refresh the canvas
            self.mpl_canvas.figure.tight_layout()
            self.mpl_canvas.draw()
            
            print("Chart generated successfully")
            
        except Exception as e:
            error_msg = f"Error creating chart: {str(e)}"
            print(f"ERROR: {error_msg}")
            import traceback
            traceback.print_exc()
            QMessageBox.critical(self, "Chart Error", error_msg)
            
        print("=== Finished update_chart ===\n")
    
    def update_filter_options(self):
        """Update filter options based on selected column"""
        print("\n=== Starting update_filter_options ===")
        try:
            if not hasattr(self, 'column_selector'):
                print("column_selector widget not found")
                return
            
            # Check if raw_data exists and is not empty
            if not hasattr(self, 'raw_data') or self.raw_data is None or self.raw_data.empty:
                print("No data available for updating filter options")
                return
                
            # Store the current selection
            try:
                current_selection = self.column_selector.currentText() if self.column_selector.count() > 0 else ""
                print(f"Current selection: '{current_selection}'")
                
                # Block signals to prevent infinite loop
                print("Blocking signals from column_selector")
                self.column_selector.blockSignals(True)
                
                try:
                    # Clear and repopulate
                    print("Clearing column_selector")
                    self.column_selector.clear()
                    
                    columns = self.raw_data.columns.tolist()
                    print(f"Adding {len(columns)} columns to column_selector: {columns}")
                    self.column_selector.addItems(columns)
                    
                    # Restore selection if possible
                    if current_selection:
                        index = self.column_selector.findText(current_selection)
                        print(f"Restoring selection '{current_selection}', found at index {index}")
                        if index >= 0:
                            self.column_selector.setCurrentIndex(index)
                finally:
                    # Always unblock signals even if an error occurs
                    print("Unblocking signals from column_selector")
                    self.column_selector.blockSignals(False)
            except Exception as e:
                print(f"Error updating column selector: {e}")
                import traceback
                traceback.print_exc()
                # Continue as this is not critical
            
            # Handle value selection panel based on checkbox state
            try:
                print("Handling value selection panel")
                if hasattr(self, 'show_value_selection'):
                    # Check if the checkbox is checked or not
                    if self.show_value_selection.isChecked():
                        print("Value selection panel should be visible, updating the value_list")
                        
                        # Update the value list with unique values from the selected column
                        if hasattr(self, 'value_list') and current_selection:
                            # Make sure raw_data is not None and the selected column exists
                            if self.raw_data is not None and not self.raw_data.empty and current_selection in self.raw_data.columns:
                                print(f"Updating value_list with values from column: {current_selection}")
                                
                                # Block signals to prevent triggering events during updates
                                self.value_list.blockSignals(True)
                                
                                # Clear previous items
                                self.value_list.clear()
                                
                                # Get unique values and sort them
                                try:
                                    unique_values = sorted(self.raw_data[current_selection].astype(str).unique())
                                    print(f"Found {len(unique_values)} unique values")
                                    
                                    # Add values to the list and select them all by default
                                    for val in unique_values:
                                        item = QListWidgetItem(str(val))
                                        self.value_list.addItem(item)
                                        # Select all values by default
                                        item.setSelected(True)
                                        
                                    print(f"Added {self.value_list.count()} items to value_list")
                                except Exception as e:
                                    print(f"Error processing unique values: {e}")
                                    import traceback
                                    traceback.print_exc()
                                
                                # Unblock signals after updates
                                self.value_list.blockSignals(False)
                            else:
                                print(f"Cannot update value list: raw_data is None or {current_selection} not in columns")
                        else:
                            print("Missing required attributes for updating value list")
                            
                        # Make sure the right widget is visible
                        if hasattr(self, 'raw_data_splitter'):
                            right_widget = self.raw_data_splitter.widget(1)
                            if right_widget:
                                print("Showing right widget of raw_data_splitter")
                                right_widget.show()
                                # Reset splitter sizes to give reasonable proportions
                                self.raw_data_splitter.setSizes([700, 300])
                            else:
                                print("Right widget of raw_data_splitter not found")
                        else:
                            print("raw_data_splitter not found")
                    else:
                        print("Value selection panel should be hidden")
                        # Make sure the right widget is hidden
                        if hasattr(self, 'raw_data_splitter'):
                            right_widget = self.raw_data_splitter.widget(1)
                            if right_widget:
                                print("Hiding right widget of raw_data_splitter")
                                right_widget.hide()
                            else:
                                print("Right widget of raw_data_splitter not found")
                        else:
                            print("raw_data_splitter not found")
                else:
                    print("show_value_selection not found")
            except Exception as e:
                print(f"Error handling value selection panel: {e}")
                import traceback
                traceback.print_exc()
                # Continue as this is not critical
                
            print("=== update_filter_options completed successfully ===\n")
            
        except Exception as e:
            print(f"Unhandled error in update_filter_options: {e}")
            import traceback
            traceback.print_exc()
    
    def update_analysis_filter_options(self):
        """Update filter options based on selected column"""
        print("\n=== Starting update_analysis_filter_options ===")
        try:
            if not hasattr(self, 'analysis_column_selector'):
                print("analysis_column_selector widget not found")
                return
            
            # Store the current selection
            current_selection = self.analysis_column_selector.currentText() if self.analysis_column_selector.count() > 0 else ""
            print(f"Current selection: '{current_selection}'")
            
            # Block signals to prevent infinite loop
            print("Blocking signals from analysis_column_selector")
            self.analysis_column_selector.blockSignals(True)
            
            try:
                # Clear and repopulate with columns that are available for filtering
                print("Clearing analysis_column_selector")
                self.analysis_column_selector.clear()
                
                # Get columns from the raw data for filtering
                if hasattr(self, 'raw_data') and self.raw_data is not None and not self.raw_data.empty:
                    columns = self.raw_data.columns.tolist()
                    print(f"Adding {len(columns)} columns to analysis_column_selector: {columns}")
                    self.analysis_column_selector.addItems(columns)
                    
                    # Restore selection if possible
                    if current_selection:
                        index = self.analysis_column_selector.findText(current_selection)
                        print(f"Restoring selection '{current_selection}', found at index {index}")
                        if index >= 0:
                            self.analysis_column_selector.setCurrentIndex(index)
                else:
                    print("No data available for updating analysis filter options")
            finally:
                # Always unblock signals even if an error occurs
                print("Unblocking signals from analysis_column_selector")
                self.analysis_column_selector.blockSignals(False)
                
            # Make sure the analysis value selection is updated
            try:
                print("Handling analysis value selection panel")
                if hasattr(self, 'analysis_show_value_selection') and not self.analysis_show_value_selection.isChecked():
                    # If the selection panel is not visible, keep it hidden
                    if hasattr(self, 'analysis_splitter'):
                        right_widget = self.analysis_splitter.widget(1)
                        if right_widget:
                            print("Hiding right widget of analysis_splitter")
                            right_widget.hide()
                        else:
                            print("Right widget of analysis_splitter not found")
                    else:
                        print("analysis_splitter not found")
                elif hasattr(self, 'analysis_show_value_selection') and self.analysis_show_value_selection.isChecked():
                    # REMOVED RECURSIVE CALL: self.update_analysis_filter_options()
                    print("Value selection panel should be visible, updating the analysis_value_list")
                    
                    # Update the value list with unique values from the selected column
                    if hasattr(self, 'analysis_value_list') and hasattr(self, 'raw_data') and current_selection:
                        # Make sure raw_data is not None and the selected column exists
                        if self.raw_data is not None and not self.raw_data.empty and current_selection in self.raw_data.columns:
                            print(f"Updating analysis_value_list with values from column: {current_selection}")
                            
                            # Block signals to prevent triggering events during updates
                            self.analysis_value_list.blockSignals(True)
                            
                            # Clear previous items
                            self.analysis_value_list.clear()
                            
                            # Get unique values and sort them
                            try:
                                unique_values = sorted(self.raw_data[current_selection].astype(str).unique())
                                print(f"Found {len(unique_values)} unique values")
                                
                                # Add values to the list and select them all by default
                                for val in unique_values:
                                    item = QListWidgetItem(str(val))
                                    self.analysis_value_list.addItem(item)
                                    # Select all values by default
                                    item.setSelected(True)
                                    
                                print(f"Added {self.analysis_value_list.count()} items to analysis_value_list")
                            except Exception as e:
                                print(f"Error processing unique values: {e}")
                                import traceback
                                traceback.print_exc()
                            
                            # Unblock signals after updates
                            self.analysis_value_list.blockSignals(False)
                            
                            # Make sure the right widget is visible
                            if hasattr(self, 'analysis_splitter'):
                                right_widget = self.analysis_splitter.widget(1)
                                if right_widget:
                                    print("Showing right widget of analysis_splitter")
                                    right_widget.show()
                                    # Reset splitter sizes to give reasonable proportions
                                    self.analysis_splitter.setSizes([700, 300])
                                else:
                                    print("Right widget of analysis_splitter not found")
                            else:
                                print("analysis_splitter not found")
                        else:
                            print(f"Cannot update value list: raw_data is None or {current_selection} not in columns")
                    else:
                        print("Missing required attributes for updating value list")
                else:
                    print("analysis_show_value_selection not found or in indeterminate state")
            except Exception as e:
                print(f"Error handling analysis value selection panel: {e}")
                import traceback
                traceback.print_exc()
                
        except Exception as e:
            print(f"Unhandled error in update_analysis_filter_options: {e}")
            import traceback
            traceback.print_exc()
    
    def update_chart_style(self, style_name):
        """Update chart style based on selected option"""
        # Convert the style name to lowercase for the preset keys
        style_key = style_name.lower()
        if hasattr(self, 'mpl_canvas'):
            self.mpl_canvas.apply_style(style_key)
            # No need to call update_chart, just apply the style to current chart
            self.statusBar().showMessage(f"Applied {style_name} style to chart", 3000)
    
    def export_chart(self):
        """Export the current chart as an image file"""
        if not hasattr(self, 'mpl_canvas') or self.mpl_canvas is None:
            QMessageBox.warning(self, "Export Error", "No chart available to export")
            return
        
        export_dir = self.config_manager.get_export_directory()
        
        # Generate default filename based on current view and timestamp
        chart_type = self.chart_type_selector.currentText().replace(" ", "_")
        view_type = self.analysis_selector.currentText().replace(" ", "_")
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        default_filename = f"{view_type}_{chart_type}_{timestamp}.png"
        
        # Open file dialog
        filepath, _ = QFileDialog.getSaveFileName(
            self, 
            "Export Chart", 
            os.path.join(export_dir, default_filename), 
            "PNG Image (*.png);;JPEG Image (*.jpg);;PDF Document (*.pdf);;SVG Image (*.svg)"
        )
        
        if not filepath:
            return  # User cancelled
            
        try:
            # Save figure with high DPI for print quality
            saved_path = self.mpl_canvas.save_figure(filepath, dpi=300)
            self.statusBar().showMessage(f"Chart exported to {saved_path}", 5000)
        except Exception as e:
            error_msg = f"Error exporting chart: {str(e)}"
            print(f"ERROR: {error_msg}")
            import traceback
            traceback.print_exc()
            QMessageBox.critical(self, "Export Error", error_msg)
    
    def export_current_analysis(self):
        """Export the current analysis view to a CSV file"""
        if not hasattr(self, 'analysis_results') or self.analysis_results is None:
            QMessageBox.information(self, "Export", "No analysis results available to export.")
            return
            
        selected_view = self.analysis_selector.currentText()
        
        # Map the view name to the corresponding DataFrame in analysis_results
        if selected_view == "Player Total Scores":
            df = self.analysis_results['player_totals']
            default_filename = "player_total_scores.csv"
        elif selected_view == "Scores by Chest Type":
            df = self.analysis_results['chest_totals']
            default_filename = "scores_by_chest_type.csv"
        elif selected_view == "Scores by Source":
            df = self.analysis_results['source_totals']
            default_filename = "scores_by_source.csv"
        elif selected_view == "Scores by Date":
            df = self.analysis_results['date_totals']
            default_filename = "scores_by_date.csv"
        elif selected_view == "Player Average Scores":
            df = self.analysis_results['player_avg']
            default_filename = "player_average_scores.csv"
        elif selected_view == "Chest Count by Player":
            df = self.analysis_results['player_counts']
            default_filename = "chest_count_by_player.csv"
        elif selected_view == "Player Overview":
            df = self.analysis_results['player_overview']
            default_filename = "player_overview.csv"
        else:
            default_filename = "analysis_results.csv"
            # Try to use the current DataFrame if available
            if hasattr(self, 'analysis_view') and self.analysis_view.model():
                model = self.analysis_view.model()
                headers = [model.headerData(i, Qt.Horizontal, Qt.DisplayRole) for i in range(model.columnCount())]
                data = []
                for row in range(model.rowCount()):
                    row_data = []
                    for col in range(model.columnCount()):
                        item = model.data(model.index(row, col), Qt.DisplayRole)
                        row_data.append(str(item))
                    data.append(row_data)
                df = pd.DataFrame(data, columns=headers)
            else:
                QMessageBox.warning(self, "Export Error", "Could not determine which data to export.")
                return
                
        # Get export directory from config
        export_dir = self.config_manager.get_export_directory()
        default_filepath = os.path.join(export_dir, default_filename)
        
        # Ask for save location
        filepath, _ = QFileDialog.getSaveFileName(
            self, "Export Analysis", default_filepath, "CSV Files (*.csv)"
        )
        
        if filepath:
            try:
                # Save the directory for next time
                self.config_manager.set('General', 'export_directory', str(Path(filepath).parent))
                
                # Export the data
                df.to_csv(filepath, index=False)
                
                row_count = len(df)
                self.statusBar().showMessage(f"Exported {row_count} rows to {filepath}", 5000)
                
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to export data: {str(e)}")
                self.statusBar().showMessage("Error exporting data", 5000)

    def toggle_value_selection(self, state):
        """Show or hide the value selection panel based on checkbox state"""
        # Find the right widget (second widget in the splitter)
        right_widget = self.raw_data_splitter.widget(1)
        
        # State is 2 for checked, 0 for unchecked
        if state == 2:  # Qt.CheckState.Checked
            # Show value selection panel
            right_widget.show()
            # Reset splitter sizes to give reasonable proportions
            self.raw_data_splitter.setSizes([700, 300])
            
            # Check if data is available before updating filter options
            if hasattr(self, 'raw_data') and self.raw_data is not None and not self.raw_data.empty:
                # Update the value list with current column values
                self.update_filter_options()
            else:
                print("No data available for updating filter options in toggle_value_selection")
        else:
            # Hide value selection panel
            right_widget.hide()
    
    def filter_raw_data(self):
        """Filter raw data based on selected criteria"""
        if self.raw_data is None or self.raw_data.empty or self.column_selector.currentText() == "":
            return
            
        # Get the current filter state
        column_name = self.column_selector.currentText()
        date_filter_enabled = self.date_filter_enabled.isChecked()
        value_selection_enabled = self.show_value_selection.isChecked()
        
        # Start with a copy of the original data
        filtered_data = self.raw_data.copy()
        
        # If value selection is enabled, use selected items
        if value_selection_enabled:
            selected_items = self.value_list.selectedItems()
            if selected_items:
                selected_values = [item.text() for item in selected_items]
                filtered_data = filtered_data[filtered_data[column_name].astype(str).isin(selected_values)]
                
                # Show status message about column filtering
                status_message = f"Filtered by {column_name}: {len(selected_values)} values selected"
            else:
                # No column filter applied (no values selected)
                status_message = "Warning: No values selected for filtering - no results"
                QMessageBox.warning(self, "Filter Warning", "No values are selected. Please select at least one value.")
                return
        else:
            # Value selection is not enabled - using all values
            status_message = f"Using all values for {column_name}"
        
        # Apply date filter if enabled
        if date_filter_enabled and 'DATE' in filtered_data.columns:
            start_date = self.start_date_edit.date().toString("yyyy-MM-dd")
            end_date = self.end_date_edit.date().toString("yyyy-MM-dd")
            
            # Filter by date range
            filtered_data = filtered_data[(filtered_data['DATE'] >= start_date) & 
                                         (filtered_data['DATE'] <= end_date)]
            
            # Add date filter info to status message
            status_message += f", Date range: {start_date} to {end_date}"
        
        # If no data after filtering, show message and return
        if filtered_data.empty:
            QMessageBox.warning(self, "Filter Results", "No data matches the selected filters.")
            return
        
        # Update the model with filtered data
        headers = filtered_data.columns.tolist()
        data = [row.tolist() for _, row in filtered_data.iterrows()]
        
        # Update the model
        self.raw_data_model.setData(data, headers)
        
        # Display filter status
        self.statusBar().showMessage(status_message, 5000)
    
    def clear_filters(self):
        """Clear all filters"""
        if not hasattr(self, 'raw_data_proxy_model'):
            return
            
        # Hide value selection panel
        self.show_value_selection.setChecked(False)
        
        # Reset date filter
        self.date_filter_enabled.setChecked(False)
        self.start_date_edit.setDate(QDate.currentDate().addDays(-30))
        self.end_date_edit.setDate(QDate.currentDate())
        
        # Reset to original data
        if hasattr(self, 'raw_data') and self.raw_data is not None:
            self.update_raw_data_view()
            
        self.statusBar().showMessage("Filters cleared", 3000)
    
    def export_raw_data(self):
        """Export the currently displayed raw data to a CSV file"""
        if not hasattr(self, 'raw_data_proxy_model') or not hasattr(self, 'raw_data_model'):
            QMessageBox.warning(self, "Warning", "No data available to export.")
            return
        
        # Get the filtered data from the current view
        model = self.raw_data_table.model()
        if model is None:
            QMessageBox.warning(self, "Warning", "No data model available.")
            return
        
        # Get the number of rows and columns in the current view
        row_count = model.rowCount()
        column_count = model.columnCount()
        
        if row_count == 0 or column_count == 0:
            QMessageBox.warning(self, "Warning", "No data to export.")
            return
        
        # Extract headers and data from the model
        headers = [model.headerData(j, Qt.Horizontal, Qt.DisplayRole) for j in range(column_count)]
        
        # Extract data rows
        data_rows = []
        for i in range(row_count):
            row_data = []
            for j in range(column_count):
                index = model.index(i, j)
                value = model.data(index, Qt.DisplayRole)
                row_data.append(value)
            data_rows.append(row_data)
        
        # Create a DataFrame from the extracted data
        import pandas as pd
        df = pd.DataFrame(data_rows, columns=headers)
        
        # Get export directory from config
        export_dir = self.config_manager.get_export_directory()
        default_filename = os.path.join(export_dir, "raw_data_export.csv")
        
        # Ask for save location
        filepath, _ = QFileDialog.getSaveFileName(
            self, "Export Raw Data", default_filename, "CSV Files (*.csv)"
        )
        
        if filepath:
            try:
                # Save the directory for next time
                self.config_manager.set('General', 'export_directory', str(Path(filepath).parent))
                
                # Export the data
                df.to_csv(filepath, index=False)
                self.statusBar().showMessage(f"Exported {row_count} rows to {filepath}", 5000)
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to export data: {str(e)}")
                self.statusBar().showMessage("Error exporting data", 5000)
    
    def select_all_values(self):
        """Select all items in the value list"""
        for index in range(self.value_list.count()):
            self.value_list.item(index).setSelected(True)
    
    def deselect_all_values(self):
        """Deselect all items in the value list"""
        self.value_list.clearSelection()
    
    def toggle_analysis_value_selection(self, state):
        """Show or hide the value selection panel based on checkbox state"""
        # Find the right widget (second widget in the splitter)
        right_widget = self.analysis_splitter.widget(1)
        
        # State is 2 for checked, 0 for unchecked
        if state == 2:  # Qt.CheckState.Checked
            # Show value selection panel
            right_widget.show()
            # Reset splitter sizes to give reasonable proportions
            self.analysis_splitter.setSizes([700, 300])
            
            # Check if data is available before updating filter options
            if hasattr(self, 'raw_data') and self.raw_data is not None and not self.raw_data.empty:
                # Update the value list with current column values
                self.update_analysis_filter_options()
            else:
                print("No data available for updating filter options in toggle_analysis_value_selection")
        else:
            # Hide value selection panel
            right_widget.hide()
            # If hiding, select all values by default
            if hasattr(self, 'analysis_value_list'):
                self.select_all_analysis_values()
    
    def filter_analysis_data(self):
        """Filter analysis data based on selected criteria"""
        if self.raw_data is None or self.raw_data.empty:
            print("No raw data available for filtering")
            return
            
        # Check if we need to auto-select the first column when none is selected
        # This handles the case when this method is called automatically on startup
        if self.analysis_column_selector.currentText() == "":
            if self.analysis_column_selector.count() > 0:
                print("No column selected, auto-selecting the first column")
                self.analysis_column_selector.setCurrentIndex(0)
            else:
                print("No columns available in the selector")
                return
                
        # Get the current filter state
        column_name = self.analysis_column_selector.currentText()
        print(f"Filtering by column: {column_name}")
        date_filter_enabled = self.analysis_date_filter_enabled.isChecked()
        value_selection_enabled = self.analysis_show_value_selection.isChecked()
        
        # Start with a copy of the original data
        filtered_data = self.raw_data.copy()
        
        # If value selection is enabled, use selected items
        if value_selection_enabled:
            selected_items = self.analysis_value_list.selectedItems()
            if selected_items:
                selected_values = [item.text() for item in selected_items]
                filtered_data = filtered_data[filtered_data[column_name].astype(str).isin(selected_values)]
                
                # Show status message about column filtering
                status_message = f"Filtered by {column_name}: {len(selected_values)} values selected"
            else:
                # No column filter applied (no values selected)
                status_message = "Warning: No values selected for filtering - no results"
                QMessageBox.warning(self, "Filter Warning", "No values are selected. Please select at least one value.")
                return
        else:
            # Value selection is not enabled - using all values
            status_message = f"Using all values for {column_name}"
        
        # Apply date filter if enabled
        if date_filter_enabled and 'DATE' in filtered_data.columns:
            start_date = self.analysis_start_date_edit.date().toString("yyyy-MM-dd")
            end_date = self.analysis_end_date_edit.date().toString("yyyy-MM-dd")
            
            # Filter by date range
            filtered_data = filtered_data[(filtered_data['DATE'] >= start_date) & 
                                         (filtered_data['DATE'] <= end_date)]
            
            # Add date filter info to status message
            status_message += f", Date range: {start_date} to {end_date}"
        
        # If no data after filtering, show message and return
        if filtered_data.empty:
            QMessageBox.warning(self, "Filter Results", "No data matches the selected filters.")
            return
            
        # Now reanalyze the filtered data
        try:
            # Process the filtered data with DataProcessor
            filtered_analysis = DataProcessor.analyze_data(filtered_data)
            
            # Get the current view and use that to determine which analysis to show
            selected_view = self.analysis_selector.currentText()
            
            if selected_view == "Player Total Scores":
                df = filtered_analysis['player_totals']
            elif selected_view == "Scores by Chest Type":
                df = filtered_analysis['chest_totals']
            elif selected_view == "Scores by Source":
                df = filtered_analysis['source_totals']
            elif selected_view == "Scores by Date":
                df = filtered_analysis['date_totals']
            elif selected_view == "Player Average Scores":
                df = filtered_analysis['player_avg']
            elif selected_view == "Chest Count by Player":
                df = filtered_analysis['player_counts']
            elif selected_view == "Player Overview":
                df = filtered_analysis['player_overview']
            else:
                QMessageBox.warning(self, "Filter Error", "Unknown analysis view.")
                return
                
            # Prepare data for table model
            headers = df.columns.tolist()
            data = [row.tolist() for _, row in df.iterrows()]
            
            # Create and set up model
            model = CustomTableModel(data, headers)
            
            # Set model on table view
            self.analysis_view.setModel(model)
            
            # Set column widths
            for i in range(len(headers)):
                self.analysis_view.setColumnWidth(i, 150)
                
            # Store the filtered analysis for export
            self.filtered_analysis_results = filtered_analysis
            
            # Display filter status
            self.statusBar().showMessage(status_message, 5000)
            
        except Exception as e:
            QMessageBox.critical(self, "Filter Error", f"Error filtering data: {str(e)}")
            self.statusBar().showMessage("Error filtering data", 5000)
            import traceback
            traceback.print_exc()
    
    def clear_analysis_filters(self):
        """Clear all analysis filters and reset to default view"""
        # Reset date filter to last 30 days
        today = QDate.currentDate()
        thirty_days_ago = today.addDays(-30)
        self.analysis_start_date_edit.setDate(thirty_days_ago)
        self.analysis_end_date_edit.setDate(today)
        
        # Uncheck date filter if it's checked
        if self.analysis_date_filter_enabled.isChecked():
            self.analysis_date_filter_enabled.setChecked(False)
            
        # If value selection is visible, select all values
        if self.analysis_show_value_selection.isChecked():
            self.select_all_analysis_values()
            
        # Reprocess the data with no filters
        if self.raw_data is not None and not self.raw_data.empty:
            print("Clearing filters and processing raw data for analysis")
            
            # Process the raw data with DataProcessor
            self.analysis_results = DataProcessor.analyze_data(self.raw_data)
            
            # Update the view - don't pass arguments, the method gets the selected view internally
            print("Calling update_analysis_view to refresh the table with cleared filters")
            self.update_analysis_view()
            
        # Show status message
        self.statusBar().showMessage("Analysis filters cleared", 5000)
    
    def select_all_analysis_values(self):
        """Select all items in the analysis value list"""
        for i in range(self.analysis_value_list.count()):
            self.analysis_value_list.item(i).setSelected(True)
    
    def deselect_all_analysis_values(self):
        """Deselect all items in the analysis value list"""
        self.analysis_value_list.clearSelection()
    
    def populate_filter_columns_dropdown(self):
        """
        Populate the filter columns dropdown with column names from the loaded data.
        This allows users to select which column they want to filter by.
        """
        try:
            if not hasattr(self, 'data_model') or self.data_model is None:
                print("No data model available for populating filter columns")
                return
                
            print("Populating filter columns dropdown")
            
            # Get column names from the data model
            columns = self.data_model._headers
            
            # Check if column_selector exists (this is the actual widget name used in the application)
            if hasattr(self, 'column_selector'):
                # Clear previous items
                self.column_selector.clear()
                
                # Add columns to the dropdown
                self.column_selector.addItems(columns)
                
                print(f"Added {len(columns)} columns to filter dropdown")
            else:
                print("column_selector widget not found")
                
        except Exception as e:
            print(f"Error populating filter columns: {str(e)}")
            import traceback
            traceback.print_exc()
    
    def update_date_range_from_data(self):
        """
        Update the date range controls based on the min and max dates in the data.
        This ensures that the date filter controls reflect the actual date range in the data.
        """
        print("Starting update_date_range_from_data method...")
        try:
            # Import pandas specifically in this method to ensure it's available
            try:
                import pandas as pd
                print("Pandas imported successfully")
            except ImportError as e:
                print(f"Failed to import pandas: {e}")
                return
                
            if not hasattr(self, 'raw_data') or self.raw_data is None or self.raw_data.empty:
                print("No data available for updating date range")
                return
                
            print("Updating date range from data")
            print(f"Raw data columns: {self.raw_data.columns.tolist()}")
            
            # Check if the DataFrame has 'Date' or 'Timestamp' column
            date_column = None
            for col in ['Date', 'DATE', 'Timestamp', 'date', 'timestamp', 'DateTime', 'datetime']:
                if col in self.raw_data.columns:
                    date_column = col
                    print(f"Found date column: {col}")
                    break
                    
            if date_column is None:
                print("No date column found in data")
                return
                
            # Show sample date values
            print(f"Sample date values: {self.raw_data[date_column].head().tolist()}")
            
            # Convert to datetime if not already
            try:
                print(f"Date column dtype before conversion: {self.raw_data[date_column].dtype}")
                if not pd.api.types.is_datetime64_any_dtype(self.raw_data[date_column]):
                    print("Converting date column to datetime")
                    self.raw_data[date_column] = pd.to_datetime(self.raw_data[date_column], errors='coerce')
                    print(f"Date column dtype after conversion: {self.raw_data[date_column].dtype}")
            except Exception as e:
                print(f"Error converting date column: {e}")
                import traceback
                traceback.print_exc()
                return
                
            # Get min and max dates
            try:
                min_date = self.raw_data[date_column].min()
                max_date = self.raw_data[date_column].max()
                print(f"Min date (raw): {min_date}")
                print(f"Max date (raw): {max_date}")
            except Exception as e:
                print(f"Error finding min/max dates: {e}")
                import traceback
                traceback.print_exc()
                return
            
            if pd.isna(min_date) or pd.isna(max_date):
                print("Min or max date is NaT")
                return
                
            print(f"Date range in data: {min_date} to {max_date}")
            
            # Update date controls if they exist
            if hasattr(self, 'start_date_edit') and hasattr(self, 'end_date_edit'):
                try:
                    # Get date components and ensure they're valid integers
                    min_year = int(min_date.year) if hasattr(min_date, 'year') else 2000
                    min_month = int(min_date.month) if hasattr(min_date, 'month') else 1
                    min_day = int(min_date.day) if hasattr(min_date, 'day') else 1
                    
                    max_year = int(max_date.year) if hasattr(max_date, 'year') else 2030
                    max_month = int(max_date.month) if hasattr(max_date, 'month') else 12
                    max_day = int(max_date.day) if hasattr(max_date, 'day') else 31
                    
                    # Validate ranges
                    min_month = max(1, min(12, min_month))
                    min_day = max(1, min(31, min_day))
                    max_month = max(1, min(12, max_month))
                    max_day = max(1, min(31, max_day))
                    
                    # Convert pandas Timestamp to QDate with extra validation
                    print(f"Converting dates to QDate: min={min_year}-{min_month}-{min_day}, max={max_year}-{max_month}-{max_day}")
                    
                    min_qdate = QDate(min_year, min_month, min_day)
                    max_qdate = QDate(max_year, max_month, max_day)
                    
                    # Verify QDate is valid before setting
                    print(f"QDate validity: min_valid={min_qdate.isValid()}, max_valid={max_qdate.isValid()}")
                    
                    if min_qdate.isValid() and max_qdate.isValid():
                        # Set the date range
                        print("Setting date range on controls")
                        self.start_date_edit.setDate(min_qdate)
                        self.end_date_edit.setDate(max_qdate)
                        print("Date range controls updated successfully")
                    else:
                        print(f"Invalid QDate: min_valid={min_qdate.isValid()}, max_valid={max_qdate.isValid()}")
                        # Set to safe default values
                        print("Using safe default date values instead")
                        default_start = QDate(2020, 1, 1)
                        default_end = QDate(2030, 12, 31)
                        self.start_date_edit.setDate(default_start)
                        self.end_date_edit.setDate(default_end)
                        print("Date range controls updated with default values")
                except Exception as e:
                    print(f"Error creating QDate objects: {e}")
                    import traceback
                    traceback.print_exc()
                    # Set to safe default values
                    try:
                        print("Using safe default date values due to exception")
                        default_start = QDate(2020, 1, 1)
                        default_end = QDate(2030, 12, 31)
                        self.start_date_edit.setDate(default_start)
                        self.end_date_edit.setDate(default_end)
                        print("Date range controls updated with default values after exception")
                    except Exception as ex:
                        print(f"Failed to set default dates: {ex}")
            else:
                print("Date range controls not found")
            
            print("Completed update_date_range_from_data method successfully")
                
        except Exception as e:
            print(f"Error updating date range: {str(e)}")
            import traceback
            traceback.print_exc()
        print("Exiting update_date_range_from_data method")
    
    def generate_report(self):
        """
        Generate a report based on the current selections.
        
        This method creates an HTML report based on the selected report type
        and inclusion options. The report is displayed in the report_view widget.
        """
        try:
            if self.analysis_results is None or not self.analysis_results:
                QMessageBox.warning(self, "Report Error", "No analysis results available. Please load data first.")
                return
            
            # Get report parameters
            report_type = self.report_type_selector.currentText()
            include_charts = self.include_charts_checkbox.isChecked()
            include_tables = self.include_tables_checkbox.isChecked()
            include_stats = self.include_stats_checkbox.isChecked()
            
            # Show generation status
            self.statusBar().showMessage(f"Generating {report_type}...")
            
            # Create HTML content based on report type
            if report_type == "Full Report":
                html_content = self.create_full_report_html(include_charts, include_tables, include_stats)
            elif report_type == "Player Performance":
                html_content = self.create_player_performance_html(include_charts, include_tables, include_stats)
            elif report_type == "Chest Type Analysis":
                html_content = self.create_chest_analysis_html(include_charts, include_tables, include_stats)
            elif report_type == "Source Analysis":
                html_content = self.create_source_analysis_html(include_charts, include_tables, include_stats)
            else:
                QMessageBox.warning(self, "Report Error", f"Unknown report type: {report_type}")
                return
            
            # Set the HTML content to the report view
            self.report_view.setHtml(html_content)
            
            # Update status
            self.statusBar().showMessage(f"{report_type} generated successfully")
            
        except Exception as e:
            print(f"Error generating report: {str(e)}")
            traceback.print_exc()
            QMessageBox.warning(self, "Report Error", f"An error occurred while generating the report: {str(e)}")
    
    def create_full_report_html(self, include_charts, include_tables, include_stats):
        """Create HTML content for the Full Report type"""
        # Get current date and time for the report header
        current_datetime = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # Start with the HTML header and styling
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>Total Battle Analyzer - Full Report</title>
            <style>
                body {{
                    font-family: Arial, sans-serif;
                    background-color: {DARK_THEME['background']};
                    color: {DARK_THEME['foreground']};
                    margin: 20px;
                }}
                h1, h2, h3, h4 {{
                    color: {DARK_THEME['accent']};
                }}
                .header {{
                    border-bottom: 2px solid {DARK_THEME['accent']};
                    padding-bottom: 10px;
                    margin-bottom: 20px;
                }}
                .section {{
                    margin-bottom: 30px;
                }}
                table {{
                    border-collapse: collapse;
                    width: 100%;
                    margin-bottom: 20px;
                }}
                th, td {{
                    border: 1px solid {DARK_THEME['accent_dark']};
                    padding: 8px;
                    text-align: left;
                }}
                th {{
                    background-color: {DARK_THEME['background_light']};
                    color: {DARK_THEME['accent']};
                }}
                tr:nth-child(even) {{
                    background-color: {DARK_THEME['background_light']};
                }}
                .chart-container {{
                    text-align: center;
                    margin: 20px 0;
                }}
                .stats-container {{
                    display: flex;
                    flex-wrap: wrap;
                    gap: 20px;
                }}
                .stat-box {{
                    background-color: {DARK_THEME['background_light']};
                    border: 1px solid {DARK_THEME['accent_dark']};
                    border-radius: 5px;
                    padding: 15px;
                    flex: 1;
                    min-width: 200px;
                }}
                .stat-value {{
                    font-size: 24px;
                    font-weight: bold;
                    color: {DARK_THEME['accent']};
                }}
                .footer {{
                    margin-top: 30px;
                    border-top: 1px solid {DARK_THEME['accent_dark']};
                    padding-top: 10px;
                    font-size: 0.8em;
                    text-align: center;
                }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>Total Battle Analyzer - Full Report</h1>
                <p>Generated on: {current_datetime}</p>
            </div>
        """
        
        # Overview Section
        html += """
            <div class="section">
                <h2>Overview</h2>
                <p>This report provides a comprehensive analysis of the Total Battle data, including 
                player performance, chest types, and sources.</p>
            </div>
        """
        
        # Player Performance Section
        if include_stats or include_tables or include_charts:
            html += """
                <div class="section">
                    <h2>Player Performance</h2>
            """
            
            if include_stats:
                # Extract some key statistics for the stats boxes
                try:
                    player_count = len(self.analysis_results['player_totals'])
                    total_score = self.analysis_results['player_totals']['SCORE'].sum() if 'SCORE' in self.analysis_results['player_totals'].columns else 0
                    avg_score = total_score / player_count if player_count > 0 else 0
                    top_player = self.analysis_results['player_totals'].iloc[0]['PLAYER'] if not self.analysis_results['player_totals'].empty else "N/A"
                    
                    # Get stats for the section
                    try:
                        chest_types = len(df)
                        total_chests = df['SCORE'].sum()
                        
                        html += """
                            <h3>Key Statistics</h3>
                            <div class="stats-container">
                        """
                        
                        html += f"""
                            <div class="stat-box">
                                <p>Chest Types</p>
                                <p class="stat-value">{chest_types}</p>
                            </div>
                            <div class="stat-box">
                                <p>Total Chests</p>
                                <p class="stat-value">{total_chests:,.0f}</p>
                            </div>
                        </div>
                        """
                    except Exception as e:
                        print(f"Error creating chest type stats: {e}")
                    html += "<p>Error generating statistics</p>"
            
            if include_charts:
                html += """
                    <div class="section">
                        <h2>Chest Type Visualizations</h2>
                """
                
                # Chest Type Bar Chart
                chart_file = self.generate_chart_for_report('Bar Chart', 'CHEST', 'Scores by Chest Type')
                if chart_file:
                    html += "<div class='chart-container'>\n"
                    html += f"<img src='file:///{chart_file}' alt='Scores by Chest Type' style='max-width:100%; height:auto;'>\n"
                    html += "<p>Score by Chest Type</p>\n"
                    html += "</div>\n"
                
                # Chest Type Pie Chart
                chart_file = self.generate_chart_for_report('Pie Chart', 'CHEST', 'Scores by Chest Type')
                if chart_file:
                    html += "<div class='chart-container'>\n"
                    html += f"<img src='file:///{chart_file}' alt='Chest Type Distribution' style='max-width:100%; height:auto;'>\n"
                    html += "<p>Chest Type Distribution</p>\n"
                    html += "</div>\n"
                
                html += "</div>\n"  # End of Chest Type Visualizations section
            
            if include_tables:
                html += """
                    <div class="section">
                        <h2>Chest Type Details</h2>
                """
                
                # Create chest type table
                if 'chest_totals' in self.analysis_results and not self.analysis_results['chest_totals'].empty:
                    df = self.analysis_results['chest_totals']
                    
                    # Sort by score descending
                    df = df.sort_values('SCORE', ascending=False)
                    
                    total_score = df['SCORE'].sum()
                    
                    html += "<h3>Chest Types by Value</h3>\n"
                    html += "<table>\n<tr><th>Rank</th><th>Chest Type</th><th>Total Score</th><th>Percentage</th></tr>\n"
                    
                    # Add each row to the table
                    for i, (_, row) in enumerate(df.iterrows(), 1):
                        chest = row['CHEST']
                        score = row['SCORE']
                        percentage = (score / total_score * 100) if total_score > 0 else 0
                        
                    
                    # Get stats for the section
                    try:
                        chest_types = len(df)
                        total_chests = df['SCORE'].sum()
                        
                        html += """
                            <h3>Key Statistics</h3>
                            <div class="stats-container">
                        """
                        
                        html += f"""
                            <div class="stat-box">
                                <p>Chest Types</p>
                                <p class="stat-value">{chest_types}</p>
                            </div>
                            <div class="stat-box">
                                <p>Total Chests</p>
                                <p class="stat-value">{total_chests:,.0f}</p>
                            </div>
                        </div>
                        """
                    except Exception as e:
                        print(f"Error creating chest stats: {e}")
                    html += "<p>Error generating statistics</p>"
            
            if include_charts:
                html += "<h3>Chest Type Charts</h3>\n"
                
                # Chest Type Bar Chart
                chart_file = self.generate_chart_for_report('Bar Chart', 'CHEST', 'Scores by Chest Type')
                if chart_file:
                    html += "<div class='chart-container'>\n"
                    html += f"<img src='file:///{chart_file}' alt='Scores by Chest Type' style='max-width:100%; height:auto;'>\n"
                    html += "<p>Score by Chest Type</p>\n"
                    html += "</div>\n"
                
                # Chest Type Pie Chart
                chart_file = self.generate_chart_for_report('Pie Chart', 'CHEST', 'Scores by Chest Type')
                if chart_file:
                    html += "<div class='chart-container'>\n"
                    html += f"<img src='file:///{chart_file}' alt='Chest Type Distribution' style='max-width:100%; height:auto;'>\n"
                    html += "<p>Chest Type Distribution</p>\n"
                    html += "</div>\n"
            
            if include_tables:
                html += "<h3>Chest Type Details</h3>\n"
                
                # Create a table of chest type scores
                if 'chest_totals' in self.analysis_results and not self.analysis_results['chest_totals'].empty:
                    df = self.analysis_results['chest_totals']
                    # Sort by score descending
                    df = df.sort_values('SCORE', ascending=False)
                    
                    html += "<table>\n<tr><th>Chest Type</th><th>Total Score</th><th>Percentage</th></tr>\n"
                    
                    total_score = df['SCORE'].sum()
                    
                    # Add each row to the table
                    for _, row in df.iterrows():
                        chest = row['CHEST']
                        score = row['SCORE']
                        percentage = (score / total_score * 100) if total_score > 0 else 0
                        
                        html += f"<tr><td>{chest}</td><td>{score:,.0f}</td><td>{percentage:.1f}%</td></tr>\n"
                    
                    html += "</table>\n"
                else:
                    html += "<p>No chest type data available</p>"
            
            html += "</div>\n"  # End of Chest Types section
        
        # Sources Section
        if include_stats or include_tables or include_charts:
            html += """
                <div class="section">
                    <h2>Source Analysis</h2>
            """
            
            if include_stats:
                # Extract some key statistics for sources
                try:
                    source_count = len(self.analysis_results['source_totals'])
                    
                    # Get stats for the section
                    try:
                        chest_types = len(df)
                        total_chests = df['SCORE'].sum()
                        
                        html += """
                            <h3>Key Statistics</h3>
                            <div class="stats-container">
                        """
                        
                        html += f"""
                            <div class="stat-box">
                                <p>Chest Types</p>
                                <p class="stat-value">{chest_types}</p>
                            </div>
                            <div class="stat-box">
                                <p>Total Chests</p>
                                <p class="stat-value">{total_chests:,.0f}</p>
                            </div>
                        </div>
                        """
                    except Exception as e:
                        print(f"Error creating chest type stats: {e}")
                 html += "<p>Error generating statistics</p>"
         
         if include_charts:
             html += """
                 <div class="section">
                     <h2>Chest Type Visualizations</h2>
             """
             
             # Chest Type Bar Chart
             chart_file = self.generate_chart_for_report('Bar Chart', 'CHEST', 'Scores by Chest Type')
             if chart_file:
                 html += "<div class='chart-container'>\n"
                 html += f"<img src='file:///{chart_file}' alt='Scores by Chest Type' style='max-width:100%; height:auto;'>\n"
                 html += "<p>Score by Chest Type</p>\n"
                 html += "</div>\n"
             
             # Chest Type Pie Chart
             chart_file = self.generate_chart_for_report('Pie Chart', 'CHEST', 'Scores by Chest Type')
             if chart_file:
                 html += "<div class='chart-container'>\n"
                 html += f"<img src='file:///{chart_file}' alt='Chest Type Distribution' style='max-width:100%; height:auto;'>\n"
                 html += "<p>Chest Type Distribution</p>\n"
                 html += "</div>\n"
                 
             html += "</div>\n"  # End of Chest Type Visualizations section
         
         if include_tables:
             html += """
                 <div class="section">
                     <h2>Chest Type Details</h2>
             """
             
             # Create chest type table
             if 'chest_totals' in self.analysis_results and not self.analysis_results['chest_totals'].empty:
                 df = self.analysis_results['chest_totals']
                 
                 # Sort by score descending
                 df = df.sort_values('SCORE', ascending=False)
                 
                 total_score = df['SCORE'].sum()
                 
                 html += "<h3>Chest Types by Value</h3>\n"
                 html += "<table>\n<tr><th>Rank</th><th>Chest Type</th><th>Total Score</th><th>Percentage</th></tr>\n"
                 
                 # Add each row to the table
                 for i, (_, row) in enumerate(df.iterrows(), 1):
                     chest = row['CHEST']
                     score = row['SCORE']
                     percentage = (score / total_score * 100) if total_score > 0 else 0
                     
                     html += f"<tr><td>{i}</td><td>{chest}</td><td>{score:,.0f}</td><td>{percentage:.1f}%</td></tr>\n"
                 
                 html += "</table>\n"
                 
                 # Try to add a player chest acquisition table
                 if 'player_overview' in self.analysis_results and not self.analysis_results['player_overview'].empty:
                     df_players = self.analysis_results['player_overview']
                     
                     # Sort by chest count descending
                     if 'CHEST_COUNT' in df_players.columns:
                         df_players = df_players.sort_values('CHEST_COUNT', ascending=False)
                         
                         html += "<h3>Top Players by Chest Acquisition</h3>\n"
                         html += "<table>\n<tr><th>Rank</th><th>Player</th><th>Chest Count</th><th>Percentage</th></tr>\n"
                         
                         total_chests = df_players['CHEST_COUNT'].sum()
                         
                         # Add each row to the table (limit to top 10)
                         for i, (_, row) in enumerate(df_players.head(10).iterrows(), 1):
                             player = row['PLAYER']
                             count = row['CHEST_COUNT']
                             percentage = (count / total_chests * 100) if total_chests > 0 else 0
                             
                             html += f"<tr><td>{i}</td><td>{player}</td><td>{count:,.0f}</td><td>{percentage:.1f}%</td></tr>\n"
                         
                         html += "</table>\n"
             else:
                 html += "<p>No chest type data available</p>"
                 
             html += "</div>\n"  # End of Chest Type Details section
         
         # Footer
         html += f"""
             <div class="footer">
                 <p>Total Battle Analyzer - Chest Type Analysis Report generated on {current_datetime}</p>
             </div>
         </body>
         </html>
         """
         
         return html
     
    def create_source_analysis_html(self, include_charts, include_tables, include_stats):
        """Create HTML content for the Source Analysis report type"""
        # Get current date and time for the report header
        current_datetime = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # Start with the HTML header and styling
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>Total Battle Analyzer - Source Analysis</title>
            <style>
                body {{
                    font-family: Arial, sans-serif;
                    background-color: {DARK_THEME['background']};
                    color: {DARK_THEME['foreground']};
                    margin: 20px;
                }}
                h1, h2, h3, h4 {{
                    color: {DARK_THEME['accent']};
                }}
                .header {{
                    border-bottom: 2px solid {DARK_THEME['accent']};
                    padding-bottom: 10px;
                    margin-bottom: 20px;
                }}
                .section {{
                    margin-bottom: 30px;
                }}
                table {{
                    border-collapse: collapse;
                    width: 100%;
                    margin-bottom: 20px;
                }}
                th, td {{
                    border: 1px solid {DARK_THEME['accent_dark']};
                    padding: 8px;
                    text-align: left;
                }}
                th {{
                    background-color: {DARK_THEME['background_light']};
                    color: {DARK_THEME['accent']};
                }}
                tr:nth-child(even) {{
                    background-color: {DARK_THEME['background_light']};
                }}
                .chart-container {{
                    text-align: center;
                    margin: 20px 0;
                }}
                .stats-container {{
                    display: flex;
                    flex-wrap: wrap;
                    gap: 20px;
                }}
                .stat-box {{
                    background-color: {DARK_THEME['background_light']};
                    border: 1px solid {DARK_THEME['accent_dark']};
                    border-radius: 5px;
                    padding: 15px;
                    flex: 1;
                    min-width: 200px;
                }}
                .stat-value {{
                    font-size: 24px;
                    font-weight: bold;
                    color: {DARK_THEME['accent']};
                }}
                .footer {{
                    margin-top: 30px;
                    border-top: 1px solid {DARK_THEME['accent_dark']};
                    padding-top: 10px;
                    font-size: 0.8em;
                    text-align: center;
                }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>Total Battle Analyzer - Source Analysis</h1>
                <p>Generated on: {current_datetime}</p>
            </div>
        """
        
        # Overview Section
        html += """
            <div class="section">
                <h2>Source Overview</h2>
                <p>This report provides detailed analysis of score sources, including distribution, 
                value comparison, and player acquisition patterns.</p>
            </div>
        """
        
        # Source Statistics
        if include_stats:
            # Extract some key statistics for sources
            try:
                source_count = len(self.analysis_results['source_totals'])
                total_score = self.analysis_results['source_totals']['SCORE'].sum() if 'SCORE' in self.analysis_results['source_totals'].columns else 0
                
                # Get highest value source
                if not self.analysis_results['source_totals'].empty:
                    df_sorted = self.analysis_results['source_totals'].sort_values('SCORE', ascending=False)
                    top_source = df_sorted.iloc[0]['SOURCE'] if not df_sorted.empty else "N/A"
                    top_source_score = df_sorted.iloc[0]['SCORE'] if not df_sorted.empty else 0
                    top_source_percentage = (top_source_score / total_score * 100) if total_score > 0 else 0
                else:
                    top_source = "N/A"
                    top_source_score = 0
                    top_source_percentage = 0
                
                html += """
                    <div class="section">
                        <h2>Key Source Statistics</h2>
                        <div class="stats-container">
                """
                
                html += f"""
                    <div class="stat-box">
                        <p>Total Sources</p>
                        <p class="stat-value">{source_count}</p>
                    </div>
                    <div class="stat-box">
                        <p>Total Score</p>
                        <p class="stat-value">{total_score:,.0f}</p>
                    </div>
                </div>
                <div class="stats-container">
                    <div class="stat-box">
                        <p>Top Source</p>
                        <p class="stat-value">{top_source}</p>
                        <p>Total Score: {top_source_score:,.0f}</p>
                        <p>Percentage: {top_source_percentage:.1f}%</p>
                    </div>
                </div>
                """
            except Exception as e:
                        print(f"Error creating source stats: {e}")
                html += "<p>Error generating statistics</p>"
        
        if include_charts:
            html += """
                <div class="section">
                    <h2>Source Visualizations</h2>
            """
            
            # Source Bar Chart
            chart_file = self.generate_chart_for_report('Bar Chart', 'SOURCE', 'Scores by Source')
            if chart_file:
                html += "<div class='chart-container'>\n"
                html += f"<img src='file:///{chart_file}' alt='Scores by Source' style='max-width:100%; height:auto;'>\n"
                html += "<p>Score by Source</p>\n"
                html += "</div>\n"
            
            # Source Pie Chart
            chart_file = self.generate_chart_for_report('Pie Chart', 'SOURCE', 'Scores by Source')
            if chart_file:
                html += "<div class='chart-container'>\n"
                html += f"<img src='file:///{chart_file}' alt='Source Distribution' style='max-width:100%; height:auto;'>\n"
                html += "<p>Source Distribution</p>\n"
                html += "</div>\n"
            
            # Stacked Bar Chart for player sources
            chart_file = self.generate_chart_for_report('Stacked Bar Chart', 'PLAYER', 'Player Overview')
            if chart_file:
                html += "<div class='chart-container'>\n"
                html += f"<img src='file:///{chart_file}' alt='Player Scores by Source' style='max-width:100%; height:auto;'>\n"
                html += "<p>Player Score Breakdown by Source</p>\n"
                html += "</div>\n"
                
            html += "</div>\n"  # End of Source Visualizations section
        
        if include_tables:
            html += """
                <div class="section">
                    <h2>Source Details</h2>
            """
            
            # Create source table
            if 'source_totals' in self.analysis_results and not self.analysis_results['source_totals'].empty:
                df = self.analysis_results['source_totals']
                
                # Sort by score descending
                df = df.sort_values('SCORE', ascending=False)
                
                total_score = df['SCORE'].sum()
                
                html += "<h3>Sources by Value</h3>\n"
                html += "<table>\n<tr><th>Rank</th><th>Source</th><th>Total Score</th><th>Percentage</th></tr>\n"
                
                # Add each row to the table
                for i, (_, row) in enumerate(df.iterrows(), 1):
                    source = row['SOURCE']
                    score = row['SCORE']
                    percentage = (score / total_score * 100) if total_score > 0 else 0
                    
                    html += f"<tr><td>{i}</td><td>{source}</td><td>{score:,.0f}</td><td>{percentage:.1f}%</td></tr>\n"
                
                html += "</table>\n"
                
                # Try to add source breakdown by player
                if 'player_overview' in self.analysis_results and not self.analysis_results['player_overview'].empty:
                    df_players = self.analysis_results['player_overview']
                    source_columns = [col for col in df_players.columns if col not in ['PLAYER', 'TOTAL_SCORE', 'CHEST_COUNT', 'EFFICIENCY']]
                    
                    if source_columns:
                        html += "<h3>Player Source Distribution</h3>\n"
                        html += "<p>How different players acquire scores from various sources</p>\n"
                        html += "<table>\n<tr><th>Player</th><th>Total Score</th>"
                        
                        # Add source columns
                        for source in source_columns:
                            html += f"<th>{source}</th>"
                            
                        html += "</tr>\n"
                        
                        # Sort by total score
                        df_players = df_players.sort_values('TOTAL_SCORE', ascending=False)
                        
                        # Add each player row
                        for _, row in df_players.iterrows():
                            player = row['PLAYER']
                            total_score = row['TOTAL_SCORE']
                            
                            html += f"<tr><td>{player}</td><td>{total_score:,.0f}</td>"
                            
                            # Add source breakdowns
                            for source in source_columns:
                                if source in row and not pd.isna(row[source]):
                                    score = row[source]
                                    percentage = (score / total_score * 100) if total_score > 0 else 0
                                    html += f"<td>{score:,.0f} ({percentage:.1f}%)</td>"
                                else:
                                    html += "<td>0 (0.0%)</td>"
                            
                            html += "</tr>\n"
                        
                        html += "</table>\n"
            else:
                html += "<p>No source data available</p>"
                
            html += "</div>\n"  # End of Source Details section
        
        # Footer
        html += f"""
            <div class="footer">
                <p>Total Battle Analyzer - Source Analysis Report generated on {current_datetime}</p>
            </div>
        </body>
        </html>
        """
        
        return html
    
    def export_report(self):
        """
        Export the currently displayed report to HTML or PDF.
        
        This method allows the user to save the current report as an HTML or
        PDF file for sharing or future reference.
        """
        try:
            if not self.report_view.toHtml():
                QMessageBox.warning(self, "Export Error", "No report to export. Please generate a report first.")
                return
            
            # Get report type
            report_type = self.report_type_selector.currentText()
            
            # Create a suggested filename based on the report type
            filename_safe_report_type = report_type.replace(" ", "_")
            suggested_filename = f"TotalBattle_{filename_safe_report_type}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            
            # Get the export directory from config
            export_dir = self.config_manager.get_export_directory()
            if not os.path.exists(export_dir):
                os.makedirs(export_dir, exist_ok=True)
            
            # Show file dialog to select export format and location
            export_options = "HTML Files (*.html);;PDF Files (*.pdf)"
            filepath, selected_filter = QFileDialog.getSaveFileName(
                self, "Export Report", os.path.join(export_dir, suggested_filename), export_options
            )
            
            if not filepath:
                return
            
            # Save the current directory for next time
            self.config_manager.set_export_directory(str(Path(filepath).parent))
            
            # Export based on selected format
            if "HTML" in selected_filter:
                # Export as HTML
                with open(filepath, 'w', encoding='utf-8') as f:
                    f.write(self.report_view.toHtml())
                self.statusBar().showMessage(f"Report exported as HTML to {filepath}", 5000)
            elif "PDF" in selected_filter:
                # Export as PDF
                printer = QPrinter(QPrinter.HighResolution)
                printer.setOutputFormat(QPrinter.PdfFormat)
                printer.setOutputFileName(filepath)
                
                # Optional: Show page setup dialog
                page_dialog = QPageSetupDialog(printer, self)
                if page_dialog.exec():
                    # Render HTML content to PDF
                    self.report_view.print_(printer)
                    self.statusBar().showMessage(f"Report exported as PDF to {filepath}", 5000)
            
        except Exception as e:
            print(f"Error exporting report: {str(e)}")
            traceback.print_exc()
            QMessageBox.warning(self, "Export Error", f"An error occurred while exporting the report: {str(e)}")
    
    def generate_chart_for_report(self, chart_type, category_field, title):
        """
        Generate a chart image for the report.
        
        This helper method creates a chart image file that can be included in HTML reports.
        
        Args:
            chart_type (str): The type of chart to generate (e.g., 'Bar Chart', 'Pie Chart')
            category_field (str): The field to use for categorization (e.g., 'PLAYER', 'CHEST')
            title (str): The title of the chart
             
        Returns:
            str: The path to the generated chart image file, or None on failure
        """
        try:
            # Create a temporary file for the chart
            temp_file = tempfile.NamedTemporaryFile(suffix=".png", delete=False)
            temp_file.close()
            
            # Determine which dataset to use based on title
            if 'Player Overview' in title:
                if 'player_overview' not in self.analysis_results or self.analysis_results['player_overview'].empty:
                    return None
                df = self.analysis_results['player_overview']
            elif 'Player Total Scores' in title:
                if 'player_totals' not in self.analysis_results or self.analysis_results['player_totals'].empty:
                    return None
                df = self.analysis_results['player_totals']
            elif 'Chest Type' in title:
                if 'chest_totals' not in self.analysis_results or self.analysis_results['chest_totals'].empty:
                    return None
                df = self.analysis_results['chest_totals']
            elif 'Source' in title:
                if 'source_totals' not in self.analysis_results or self.analysis_results['source_totals'].empty:
                    return None
                df = self.analysis_results['source_totals']
            else:
                return None
            
            # Create the figure for the chart
            plt.figure(figsize=(10, 6))
            
            # Set the style for the chart
            plt.style.use('dark_background')
            
            # Generate the appropriate type of chart
            if chart_type == 'Bar Chart':
                if category_field == 'PLAYER':
                    data = df.sort_values('SCORE', ascending=False)
                    plt.bar(data['PLAYER'], data['SCORE'], color=TABLEAU_COLORS)
                    plt.xticks(rotation=45, ha='right')
                    plt.ylabel('Score')
                    plt.title('Player Total Scores')
                elif category_field == 'CHEST':
                    data = df.sort_values('SCORE', ascending=False)
                    plt.bar(data['CHEST'], data['SCORE'], color=TABLEAU_COLORS)
                    plt.xticks(rotation=45, ha='right')
                    plt.ylabel('Score')
                    plt.title('Scores by Chest Type')
                elif category_field == 'SOURCE':
                    data = df.sort_values('SCORE', ascending=False)
                    plt.bar(data['SOURCE'], data['SCORE'], color=TABLEAU_COLORS)
                    plt.xticks(rotation=45, ha='right')
                    plt.ylabel('Score')
                    plt.title('Scores by Source')
                    
            elif chart_type == 'Pie Chart':
                if category_field == 'CHEST':
                    data = df.sort_values('SCORE', ascending=False)
                    plt.pie(data['SCORE'], labels=data['CHEST'], autopct='%1.1f%%', 
                            startangle=90, colors=TABLEAU_COLORS)
                    plt.axis('equal')
                    plt.title('Chest Type Distribution by Score')
                elif category_field == 'SOURCE':
                    data = df.sort_values('SCORE', ascending=False)
                    plt.pie(data['SCORE'], labels=data['SOURCE'], autopct='%1.1f%%', 
                            startangle=90, colors=TABLEAU_COLORS)
                    plt.axis('equal')
                    plt.title('Source Distribution by Score')
                    
            elif chart_type == 'Stacked Bar Chart' and category_field == 'PLAYER':
                # Get the player and source columns
                player_col = 'PLAYER'
                data_cols = [col for col in df.columns if col not in 
                             ['PLAYER', 'TOTAL_SCORE', 'CHEST_COUNT', 'EFFICIENCY']]
                 
                if data_cols:
                    # Sort by total score
                    data = df.sort_values('TOTAL_SCORE', ascending=False)
                     
                    # Create the stacked bar chart
                    bottom = np.zeros(len(data))
                    for i, col in enumerate(data_cols):
                        if col in data.columns:
                            values = data[col].fillna(0).values
                            plt.bar(data[player_col], values, bottom=bottom, 
                                    label=col, color=TABLEAU_COLORS[i % len(TABLEAU_COLORS)])
                            bottom += values
                     
                    plt.xticks(rotation=45, ha='right')
                    plt.ylabel('Score')
                    plt.title('Player Scores by Source')
                    plt.legend(title='Source', bbox_to_anchor=(1.05, 1), loc='upper left')
                    plt.tight_layout()
                    
            elif chart_type == 'Bubble Chart' and category_field == 'TOTAL_SCORE':
                # Check if we have the necessary columns
                if 'TOTAL_SCORE' in df.columns and 'CHEST_COUNT' in df.columns:
                    # Filter out any rows with zeroes to avoid divide by zero
                    data = df[(df['TOTAL_SCORE'] > 0) & (df['CHEST_COUNT'] > 0)]
                     
                    if not data.empty:
                        # Calculate efficiency for sizing the bubbles
                        efficiency = data['TOTAL_SCORE'] / data['CHEST_COUNT']
                         
                        # Calculate sizes proportional to efficiency
                        max_size = 1000
                        min_size = 100
                        size_scale = ((efficiency - efficiency.min()) / 
                                      (efficiency.max() - efficiency.min())) * (max_size - min_size) + min_size
                         
                        # Create the bubble chart
                        scatter = plt.scatter(data['CHEST_COUNT'], data['TOTAL_SCORE'], 
                                              s=size_scale, alpha=0.6, 
                                              c=range(len(data)), cmap='viridis')
                         
                        # Add player labels
                        for i, player in enumerate(data['PLAYER']):
                            plt.annotate(player, 
                         # Add player labels
                         for i, player in enumerate(data['PLAYER']):
                             plt.annotate(player, 
                                          (data['CHEST_COUNT'].iloc[i], data['TOTAL_SCORE'].iloc[i]),
                                          xytext=(5, 5), textcoords='offset points')
                         
                         plt.xlabel('Chest Count')
                         plt.ylabel('Total Score')
                         plt.title('Player Efficiency (Score vs Chest Count)')
                         
                         # Add a colorbar to show efficiency
                         colorbar = plt.colorbar(scatter)
                         colorbar.set_label('Efficiency (pts/chest)')
             
             # Adjust layout and save
             plt.tight_layout()
             plt.savefig(temp_file.name, format='png', dpi=150, bbox_inches='tight')
             plt.close()
             
             return temp_file.name
             
         except Exception as e:
                        print(f"Error generating chart for report: {e}")
             traceback.print_exc()
             if 'temp_file' in locals() and os.path.exists(temp_file.name):
                 try:
                     os.unlink(temp_file.name)
                 except:
                     pass
             return None
